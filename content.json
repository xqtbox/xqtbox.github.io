{"meta":{"title":"博客堂","subtitle":"大海航行靠舵手，万物生长靠太阳","description":"Note","author":"Qingtang","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-01-18T06:05:24.000Z","updated":"2018-01-18T07:48:30.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-18T05:46:59.000Z","updated":"2018-01-18T07:48:12.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-01-18T05:39:45.000Z","updated":"2018-01-18T07:44:50.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-01-11T03:11:11.000Z","updated":"2018-01-23T02:36:36.264Z","comments":true,"path":"2018/01/11/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/11/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"python结巴分词、jieba加载停用词表","slug":"python结巴分词、jieba加载停用词表","date":"2017-09-03T13:07:04.000Z","updated":"2018-01-22T13:33:22.034Z","comments":true,"path":"2017/09/03/python结巴分词、jieba加载停用词表/","link":"","permalink":"http://yoursite.com/2017/09/03/python结巴分词、jieba加载停用词表/","excerpt":"python结巴分词1 jieba中文分词简介中文分词是中文NLP的第一步，一个优秀的分词系统取决于足够的语料和完善的模型，很多机构和公司也都会开发和维护自己的分词系统。","text":"python结巴分词1 jieba中文分词简介中文分词是中文NLP的第一步，一个优秀的分词系统取决于足够的语料和完善的模型，很多机构和公司也都会开发和维护自己的分词系统。 这里推荐的是一款完全开源、简单易用的分词工具，jieba中文分词。官网在这里，https://github.com/fxsjy/jieba 里面提供了详细的说明文档。虽然jieba分词的性能并不是最优秀的，但它开源免费、使用简单、功能丰富，并且支持多种编程语言实现。 2 中文分词的原理中文分词的模型实现主要分类两大类：基于规则和基于统计。 2.1 基于规则基于规则是指根据一个已有的词典，采用前向最大匹配、后向最大匹配、双向最大匹配等人工设定的规则来进行分词。 例如对于“上海自来水来自海上”这句话，使用前向最大匹配，即从前向后扫描，使分出来的词存在于词典中并且尽可能长，则可以得到“上海/自来水/来自/海上”。这类方法思想简单且易于实现，对数据量的要求也不高。 当然，分词所使用的规则可以设计得更复杂，从而使分词效果更理想。但是由于中文博大精深、语法千变万化，很难设计足够全面而通用的规则，并且具体的上下文语境、词语之间的搭配组合也都会影响到最终的分词结果，这些挑战都使得基于规则的分词模型愈发力不从心。 2.2 基于统计基于统计是从大量人工标注语料中总结词的概率分布以及词之间的常用搭配，使用有监督学习训练分词模型。 对于“上海自来水来自海上”这句话，一个最简单的统计分词想法是，尝试所有可能的分词方案，因为任何两个字之间，要么需要切分，要么无需切分。 对于全部可能的分词方案，根据语料统计每种方案出现的概率，然后保留概率最大的一种。很显然，“上海/自来水/来自/海上”的出现概率比“上海自/来水/来自/海上”更高，因为“上海”和“自来水”在标注语料中出现的次数比“上海自”和“来水”更多。 2.3 jieba的原理jieba分词结合了基于规则和基于统计两类方法。 首先基于前缀词典进行词图扫描，前缀词典是指词典中的词按照前缀包含的顺序排列，例如词典中出现了“上”，之后以“上”开头的词都会出现在这一块，例如“上海”，进而会出现“上海市”，从而形成一种层级包含结构。 如果将词看作节点，词和词之间的分词符看作边，那么一种分词方案则对应着从第一个字到最后一个字的一条分词路径。因此，基于前缀词典可以快速构建包含全部可能分词结果的有向无环图，这个图中包含多条分词路径，有向是指全部的路径都始于第一个字、止于最后一个字，无环是指节点之间不构成闭环。 基于标注语料，使用动态规划的方法可以找出最大概率路径，并将其作为最终的分词结果。 3 安装结巴jieba以下我们使用Python中的jieba分词完成一些基础NLP任务，如果对jieba分词感兴趣，希望了解更多内容，可以参考官方使用文档。首先没有jieba分词的话需要安装，使用pip即可。 1pip install jieba 4 jieba三种分词模式以及其应用jieba提供了三种分词模式： 精确模式：试图将句子最精确地切开，适合文本分析；cut_all=True 全模式：把句子中所有可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义；cut_all=False 搜索引擎模式：在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。jieba.cut_for_search() 以下代码使用jieba实现中文分词，使用jieba.cut()函数并传入待分词的文本字符串即可，使用cut_all参数控制选择使用全模式还是精确模式，默认为精确模式。如果需要使用搜索引擎模式，使用jieba.cut_for_search()函数即可。运行以下代码之后，jieba首先会加载自带的前缀词典，然后完成相应的分词任务。 123456789101112131415import jiebaseg_list = jieba.cut(\"我来到北京清华大学\", cut_all=True)# join是split的逆操作# 即使用一个拼接符将一个列表拼成字符串print(\"/ \".join(seg_list)) # 全模式seg_list = jieba.cut(\"我来到北京清华大学\", cut_all=False)print(\"/ \".join(seg_list)) # 精确模式seg_list = jieba.cut(\"他来到了网易杭研大厦\") # 默认是精确模式print(\"/ \".join(seg_list))seg_list = jieba.cut_for_search(\"小明硕士毕业于中国科学院计算所，后在日本京都大学深造\") # 搜索引擎模式print(\"/ \".join(seg_list)) 结果： 1234我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学我/ 来到/ 北京/ 清华大学他/ 来到/ 了/ 网易/ 杭研/ 大厦小明/ 硕士/ 毕业/ 于/ 中国/ 科学/ 学院/ 科学院/ 中国科学院/ 计算/ 计算所/ ，/ 后/ 在/ 日本/ 京都/ 大学/ 日本京都大学/ 深造 5 jieba增强功能-加载自定义词典5.1 载入新自定义词典开发者可以指定自己自定义的词典，以便包含 jieba 词库里没有的词。虽然 jieba 有新词识别能力，但是自行添加新词可以保证更高的正确率 用法： jieba.load_userdict(file_name) # file_name 为文件类对象或自定义词典的路径 词典格式和 dict.txt 一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。file_name 若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。 词频省略时使用自动计算的能保证分出该词的词频。 例如： 1234创新办 3 i云计算 5凱特琳 nz台中 用法示例：https://github.com/fxsjy/jieba/blob/master/test/test_userdict.py 123之前： 李小福 / 是 / 创新 / 办 / 主任 / 也 / 是 / 云 / 计算 / 方面 / 的 / 专家 /加载自定义词库后： 李小福 / 是 / 创新办 / 主任 / 也 / 是 / 云计算 / 方面 / 的 / 专家 / 5.2 载入停用词表主要思想是分词过后，遍历一下停用词表，去掉停用词。123456789101112131415161718192021222324252627282930import jieba # jieba.load_userdict('userdict.txt') # 创建停用词list def stopwordslist(filepath): stopwords = [line.strip() for line in open(filepath, 'r', encoding='utf-8').readlines()] return stopwords # 对句子进行分词 def seg_sentence(sentence): sentence_seged = jieba.cut(sentence.strip()) stopwords = stopwordslist('./test/stopwords.txt') # 这里加载停用词的路径 outstr = '' for word in sentence_seged: if word not in stopwords: if word != '\\t': outstr += word outstr += \" \" return outstr inputs = open('./test/input.txt', 'r', encoding='utf-8') outputs = open('./test/output.txt', 'w') for line in inputs: line_seg = seg_sentence(line) # 这里的返回值是字符串 outputs.write(line_seg + '\\n') outputs.close() inputs.close() 6 jieba分词的其他应用6.1 关键词提取jieba还实现了TF-IDF和TextRank这两种关键词提取算法，直接调用即可。 当然，提取关键词的前提是中文分词，所以这里也会使用到jieba自带的前缀词典和IDF权重词典。 12345678910111213141516171819202122import jieba.analyse# 字符串前面加u表示使用unicode编码content = u'中国特色社会主义是我们党领导的伟大事业，全面推进党的建设新的伟大工程，是这一伟大事业取得胜利的关键所在。党坚强有力，事业才能兴旺发达，国家才能繁荣稳定，人民才能幸福安康。党的十八大以来，我们党坚持党要管党、从严治党，凝心聚力、直击积弊、扶正祛邪，党的建设开创新局面，党风政风呈现新气象。习近平总书记围绕从严管党治党提出一系列新的重要思想，为全面推进党的建设新的伟大工程进一步指明了方向。'# 第一个参数：待提取关键词的文本# 第二个参数：返回关键词的数量，重要性从高到低排序# 第三个参数：是否同时返回每个关键词的权重# 第四个参数：词性过滤，为空表示不过滤，若提供则仅返回符合词性要求的关键词keywords = jieba.analyse.extract_tags(content, topK=20, withWeight=True, allowPOS=())# 访问提取结果for item in keywords: # 分别为关键词和相应的权重 print item[0], item[1]# 同样是四个参数，但allowPOS默认为('ns', 'n', 'vn', 'v')# 即仅提取地名、名词、动名词、动词keywords = jieba.analyse.textrank(content, topK=20, withWeight=True, allowPOS=('ns', 'n', 'vn', 'v'))# 访问提取结果for item in keywords: # 分别为关键词和相应的权重 print item[0], item[1] 结果展示： 1234567891011121314151617181920才能 1.0管党 0.7999933934163805全面 0.7325692441985737社会主义 0.6327916888315029围绕 0.60594603358887总书记 0.5945625023471114凝心 0.5840883789052874政风 0.5792034335473362新气象 0.5772168490112909党风 0.5728262292165519呈现 0.5700456186486299推进 0.5548361394986431方向 0.5150324602730256指明 0.5113586590717408治党 0.5062232626208965局面 0.4744549207999055聚力 0.46596165707522896积弊 0.4646149902996275直击 0.46314922535402286国家 0.46179235227324805 6.2 词性标注jieba在进行中文分词的同时，还可以完成词性标注任务。根据分词结果中每个词的词性，可以初步实现命名实体识别，即将标注为nr的词视为人名，将标注为ns的词视为地名等。所有标点符号都会被标注为x，所以可以根据这个去除分词结果中的标点符号。 123456# 加载jieba.posseg并取个别名，方便调用import jieba.posseg as psegwords = pseg.cut(&quot;我爱北京天安门&quot;)for word, flag in words: # 格式化模版并传入参数 print(&apos;%s, %s&apos; % (word, flag)) 结果展示： 1234我, r爱, v北京, ns天安门, ns 参考视频：全栈数据工程师养成攻略-18-结巴分词 7 用jieba分词实战（含文件的读取与存储）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667# -*- coding: utf-8 -*-#本程序主要用于jieba分词，以及去除停用词import osimport jieba# 保存文件的函数def savefile(savepath,content): fp = open(savepath,'w',encoding='utf8',errors='ignore') fp.write(content) fp.close()# 读取文件的函数def readfile(path): fp = open(path, \"r\", encoding='utf8', errors='ignore') content = fp.read() fp.close() return content## 去除停用词的2个函数# 创建停用词listdef stopwordslist(filepath): stopwords = [line.strip() for line in open(filepath, 'r', encoding='utf-8').readlines()] return stopwords# 对句子去除停用词def movestopwords(sentence): stopwords = stopwordslist('语料/hlt_stop_words.txt') # 这里加载停用词的路径 outstr = '' for word in sentence: if word not in stopwords: if word != '\\t'and'\\n': outstr += word # outstr += \" \" return outstrcorpus_path = \"语料/train/\" # 未分词分类预料库路径seg_path = \"语料/train_seg/\" # 分词后分类语料库路径catelist = os.listdir(corpus_path) # 获取未分词目录下所有子目录for mydir in catelist: class_path = corpus_path + mydir + \"/\" # 拼出分类子目录的路径 seg_dir = seg_path + mydir + \"/\" # 拼出分词后预料分类目录 if not os.path.exists(seg_dir): # 是否存在，不存在则创建 os.makedirs(seg_dir) file_list = os.listdir(class_path) # 列举当前目录所有文件 for file_path in file_list: fullname = class_path + file_path # 路径+文件名 print(\"当前处理的文件是： \",fullname) # 语料/train/pos/pos1.txt # 语料/train/neg/neg1.txt content = readfile(fullname).strip() # 读取文件内容 content = content.replace(\"\\n\", \"\").strip() # 删除换行和多余的空格 content_seg = jieba.cut(content) # jieba分词 print(\"jieba分词后：\",content_seg) listcontent = '' for i in content_seg: listcontent += i listcontent += \" \" print(listcontent[0:10]) listcontent = movestopwords(listcontent) # 去除停用词 print(\"去除停用词后：\", listcontent[0:10]) listcontent = listcontent.replace(\" \", \" \").replace(\" \", \" \") savefile(seg_dir + file_path, \"\".join(listcontent)) # 保存 结果展示：12345分词前：和秦一对比就是弱爆了的技术分词后： 和 秦一 对比 就是 弱 爆 了 的 技术 ， 都 有点去除停用词后：秦 弱 爆 技术 都 点 不好意思 出 口碑","categories":[{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://yoursite.com/categories/自然语言处理/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"分词","slug":"分词","permalink":"http://yoursite.com/tags/分词/"},{"name":"jieba","slug":"jieba","permalink":"http://yoursite.com/tags/jieba/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"http://yoursite.com/tags/自然语言处理/"}]},{"title":"汽车之家口碑爬虫","slug":"汽车之家口碑爬虫","date":"2017-05-30T13:37:04.000Z","updated":"2018-01-23T05:16:22.317Z","comments":true,"path":"2017/05/30/汽车之家口碑爬虫/","link":"","permalink":"http://yoursite.com/2017/05/30/汽车之家口碑爬虫/","excerpt":"1.需求分析因项目需求，要爬取汽车之家的口碑数据进行下一步分析。 但是普通的爬虫软件（如八爪鱼、火车头、神箭手）无法爬取评论（该公司采取了反爬虫措施）。 经分析，发现该公司的的反爬虫措施主要是用前端js去替换显示的字体，为一些标签。并且封住鼠标右键导致不好观察源代码。 本文以解决各个问题为顺序。","text":"1.需求分析因项目需求，要爬取汽车之家的口碑数据进行下一步分析。 但是普通的爬虫软件（如八爪鱼、火车头、神箭手）无法爬取评论（该公司采取了反爬虫措施）。 经分析，发现该公司的的反爬虫措施主要是用前端js去替换显示的字体，为一些标签。并且封住鼠标右键导致不好观察源代码。 本文以解决各个问题为顺序。 2.前端js反爬虫措施分析2.1问题描述以任意车型（奥迪A4L）为例：http://k.autohome.com.cn/692/ 我们可以看到，表面上各个评论都由文字组成，但是打开F12开发者模式。我们就发现：一些形容词被替换成了span标签，如图： 他们的具体做法是： 发布的口碑正文中随机抽取某几个字使用span标签代替，标签内容位空，但css样式显示为所代替的文。 这样不会影响正常用户的阅读，只是在用鼠标选择的时候是选不到被替换的文字的，对爬虫则会造成采集内容不全的影响。 这些是用JS实现的，这是一段js代码： 12345678910111213141516171819202122232425(function(hZ_) &#123; functionEW_() &#123; = DV_()[decodeURIComponent]('%E3%80%81%E3%80%82%E4%B8%80%E4%B8%8A%E4%B8%8B%E4%B8%8D%E4%BA%86%E4%BA%94%E5%92%8C%E5%9C%B0%E5%A4%9A%E5%A4%A7%E5%A5%BD%E5%B0%8F%E5%BE%88%E5%BE%97%E6%98%AF%E7%9A%84%E7%9D%80%E8%BF%9C%E9%95%BF%E9%AB%98%EF%BC%81%EF%BC%8C%EF%BC%9F' yc_()); = la_((yc_() 23; 3; 19; 17; 9; 1; 8; 12; 18; 13; 2; 4; 16; 5; 6; 21; 15; 11; 22; 14; 24; 0; 10; 7; 20), lf_(;)); = la_((10 _7, 6 _0; 2 _33, 14 _18; 8 _45, 8 _36; 0 _71, 16 _54; 13 _76, 3 _72; 0 _107, 16 _90; 15 _110, 1 _108; 4 _139, 12 _126; 9 _152, 7 _144; 10 _169, 6 _162; 4 _193, 12 _180; 11 _204, 5 _198; 3 _230, 13 _216; 1 _250, 15 _234; 13 _256, 3 _252; 6 _281, 10 _270; 9 _296, 7 _288; 13 _310, 3 _306; 6 _335, 10 _324; 7 _352, 9 _342; 6 _371, 10 _360; 5 _390, 11 _378; 5 _408, 11 _396; 7 _424, 9 _414; 6 _443, 10 _432lf_(;)), yc_(;)); Uj_(); return;; &#125; function mS_() &#123; for (Gx_ = 0; Gx_ &lt; nf_.length; Gx_++) &#123; var su_ = Pn_(nf_[Gx_], ','); var KN_ = ''; for (Bk_ = 0; Bk_ &lt; su_.length; Bk_++) &#123; KN_ += ui_(su_[Bk_]) + ''; &#125; Kx_(Gx_, KN_); &#125; &#125; function NH_(Gx_) &#123; return '.hs_kw' + Gx_ + '_maindC'; &#125; function Ln_() &#123; return '::before &#123; content:' &#125;&#125;)(document); 他的逻辑是，预先定义好哪几个字要被替换，上面代码中的那个很多%的字符串就是被替换的文字串，然后定义好每个文字的序号，最后按照文字的序号对文字串进行重新排序并生成css样式，注意，最一开始的span标签的class属性中是有个序号的，这个序号就是用来定位应该对应哪个文字。 接下来要做的就是无非就是从js代码中找到这个文字串，找到文字串的顺序，然后进行重排，然后根据span标签序号对原文进行反向替换，从而得到完整的内容。 2.2解决方法： 从js代码中找到被替换的文字串和顺序 重排文字串 对原文中span标签根据class序号进行替换 其实2、3都比较简单，重点是第一步，找到被替换的文字串和顺序，由于源代码中js代码是被混淆过的，无法直接看出哪个 是文字串，所以首先应该对js代码进行反混淆，这个反混淆也不是说非得完整的还原所有的js代码，其实只要能反混淆到能 让我们看出文字串和顺序是什么就行了。 说一下反混淆的思路，其实很简单。就是执行起来比较麻烦而已，混淆是利用将一个简单的变量定义成复杂的js代码的方法 实现的，但这种\b混淆方式其实是有限的（这个有限指的是混淆用的工具在生成混淆代码时肯定是人为预先定义好了几种模式 ，人为定义的肯定是有限的，只要你把所有的模式找出来，就可以还原了）。举个例子 1234function iq_() &#123; &apos;return iq_&apos;; return &apos;3&apos;; &#125; 这段代码其实你可以简单的认为就是变量iq()等于’3’，使用正则匹配这样的代码模式，然后提取关键字:函数名和最后一个return的值，然后将提取到的信息保存起来用于对js代码进行全文替换。 12345678910function cz_() &#123; function _c() &#123; return &apos;cz_&apos;; &#125;; if (_c() == &apos;cz__&apos;) &#123; return _c(); &#125; else &#123; return &apos;84&apos;; &#125; &#125; 这段代码复杂了一些，增加了判断，不过也简单，利用正则匹配这样的模式，然后提取关键字:函数名、第一个return的值，判断中==后面的值，最后一个return的值，然后自己进行判断来确定cz_()的值应该是多少，保存起来进行全文替换。 以此类推，每种模式都可以使用正则来提取关键字并进行全文替换来反混淆，最后我们会得到一个大概被还原的js代码，其中的文字串和顺序都清晰可见，再使用正则匹配出来就可以了。 需要注意的一点是有时候被替换的不是单个文字，而是一些词语，这是找到的顺序是”3,1;23,5”这样的，不过这些小伎俩应该不算什么，很好解决。 下面给出完整的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403# coding:utf8import reimport urllibimport urllib.parseimport requestsdef get_char(js): all_var = &#123;&#125; # 判断混淆 无参数 返回常量 函数 if_else_no_args_return_constant_function_functions = [] \"\"\" function zX_() &#123; function _z() &#123; return '09'; &#125;; if (_z() == '09,') &#123; return 'zX_'; &#125; else &#123; return _z(); &#125; &#125; \"\"\" constant_function_regex4 = re.compile(\"\"\" function\\s+\\w+\\(\\)\\s*\\&#123;\\s* function\\s+\\w+\\(\\)\\s*\\&#123;\\s* return\\s+[\\'\\\"][^\\'\\\"]+[\\'\\\"];\\s* \\&#125;;\\s* if\\s*\\(\\w+\\(\\)\\s*==\\s*[\\'\\\"][^\\'\\\"]+[\\'\\\"]\\)\\s*\\&#123;\\s* return\\s*[\\'\\\"][^\\'\\\"]+[\\'\\\"];\\s* \\&#125;\\s*else\\s*\\&#123;\\s* return\\s*\\w+\\(\\);\\s* \\&#125;\\s* \\&#125; \"\"\", re.X) l = constant_function_regex4.findall(js) # print(\"l 38\",l) for i in l: function_name = re.search(\"\"\" function\\s+(\\w+)\\(\\)\\s*\\&#123;\\s* function\\s+\\w+\\(\\)\\s*\\&#123;\\s* return\\s+[\\'\\\"]([^\\'\\\"]+)[\\'\\\"];\\s* \\&#125;;\\s* if\\s*\\(\\w+\\(\\)\\s*==\\s*[\\'\\\"]([^\\'\\\"]+)[\\'\\\"]\\)\\s*\\&#123;\\s* return\\s*[\\'\\\"]([^\\'\\\"]+)[\\'\\\"];\\s* \\&#125;\\s*else\\s*\\&#123;\\s* return\\s*\\w+\\(\\);\\s* \\&#125;\\s* \\&#125; \"\"\", i, re.X) if_else_no_args_return_constant_function_functions.append(function_name.groups()) js = js.replace(i, \"\") # 替换全文 a, b, c, d = function_name.groups() all_var[\"%s()\" % a] = d if b == c else b # 判断混淆 无参数 返回函数 常量 if_else_no_args_return_function_constant_functions = [] \"\"\" function wu_() &#123; function _w() &#123; return 'wu_'; &#125;; if (_w() == 'wu__') &#123; return _w(); &#125; else &#123; return '5%'; &#125; &#125; \"\"\" constant_function_regex5 = re.compile(\"\"\" function\\s+\\w+\\(\\)\\s*\\&#123;\\s* function\\s+\\w+\\(\\)\\s*\\&#123;\\s* return\\s+[\\'\\\"][^\\'\\\"]+[\\'\\\"];\\s* \\&#125;;\\s* if\\s*\\(\\w+\\(\\)\\s*==\\s*[\\'\\\"][^\\'\\\"]+[\\'\\\"]\\)\\s*\\&#123;\\s* return\\s*\\w+\\(\\);\\s* \\&#125;\\s*else\\s*\\&#123;\\s* return\\s*[\\'\\\"][^\\'\\\"]+[\\'\\\"];\\s* \\&#125;\\s* \\&#125; \"\"\", re.X) l = constant_function_regex5.findall(js) # print(\"l 87\",l) for i in l: function_name = re.search(\"\"\" function\\s+(\\w+)\\(\\)\\s*\\&#123;\\s* function\\s+\\w+\\(\\)\\s*\\&#123;\\s* return\\s+[\\'\\\"]([^\\'\\\"]+)[\\'\\\"];\\s* \\&#125;;\\s* if\\s*\\(\\w+\\(\\)\\s*==\\s*[\\'\\\"]([^\\'\\\"]+)[\\'\\\"]\\)\\s*\\&#123;\\s* return\\s*\\w+\\(\\);\\s* \\&#125;\\s*else\\s*\\&#123;\\s* return\\s*[\\'\\\"]([^\\'\\\"]+)[\\'\\\"];\\s* \\&#125;\\s* \\&#125; \"\"\", i, re.X) if_else_no_args_return_function_constant_functions.append(function_name.groups()) js = js.replace(i, \"\") # 替换全文 a, b, c, d = function_name.groups() all_var[\"%s()\" % a] = b if b == c else d # var 参数等于返回值函数 var_args_equal_value_functions = [] \"\"\" var ZA_ = function(ZA__) &#123; 'return ZA_'; return ZA__; &#125;; \"\"\" constant_function_regex1 = re.compile( \"var\\s+[^=]+=\\s*function\\(\\w+\\)\\&#123;\\s*[\\'\\\"]return\\s*\\w+\\s*[\\'\\\"];\\s*return\\s+\\w+;\\s*\\&#125;;\") l = constant_function_regex1.findall(js) # print(\"l 119\",l) for i in l: function_name = re.search(\"var\\s+([^=]+)\", i).group(1) var_args_equal_value_functions.append(function_name) js = js.replace(i, \"\") # 替换全文 a = function_name js = re.sub(\"%s\\(([^\\)]+)\\)\" % a, r\"\\1\", js) # var 无参数 返回常量 函数 var_no_args_return_constant_functions = [] \"\"\" var Qh_ = function() &#123; 'return Qh_'; return ';'; &#125;; \"\"\" constant_function_regex2 = re.compile(\"\"\" var\\s+[^=]+=\\s*function\\(\\)\\&#123;\\s* [\\'\\\"]return\\s*\\w+\\s*[\\'\\\"];\\s* return\\s+[\\'\\\"][^\\'\\\"]+[\\'\\\"];\\s* \\&#125;; \"\"\", re.X) l = constant_function_regex2.findall(js) # print(\"l 144\",l) for i in l: function_name = re.search(\"\"\" var\\s+([^=]+)=\\s*function\\(\\)\\&#123;\\s* [\\'\\\"]return\\s*\\w+\\s*[\\'\\\"];\\s* return\\s+[\\'\\\"]([^\\'\\\"]+)[\\'\\\"];\\s* \\&#125;; \"\"\", i, re.X) var_no_args_return_constant_functions.append(function_name.groups()) js = js.replace(i, \"\") # 替换全文 a, b = function_name.groups() all_var[\"%s()\" % a] = b # 无参数 返回常量 函数 no_args_return_constant_functions = [] \"\"\" function ZP_() &#123; 'return ZP_'; return 'E'; &#125; \"\"\" constant_function_regex3 = re.compile(\"\"\" function\\s*\\w+\\(\\)\\s*\\&#123;\\s* [\\'\\\"]return\\s*[^\\'\\\"]+[\\'\\\"];\\s* return\\s*[\\'\\\"][^\\'\\\"]+[\\'\\\"];\\s* \\&#125;\\s* \"\"\", re.X) l = constant_function_regex3.findall(js) # print(\"l 176\",l) for i in l: function_name = re.search(\"\"\" function\\s*(\\w+)\\(\\)\\s*\\&#123;\\s* [\\'\\\"]return\\s*[^\\'\\\"]+[\\'\\\"];\\s* return\\s*[\\'\\\"]([^\\'\\\"]+)[\\'\\\"];\\s* \\&#125;\\s* \"\"\", i, re.X) no_args_return_constant_functions.append(function_name.groups()) js = js.replace(i, \"\") # 替换全文 a, b = function_name.groups() all_var[\"%s()\" % a] = b # 无参数 返回常量 函数 中间无混淆代码 no_args_return_constant_sample_functions = [] \"\"\" function do_() &#123; return ''; &#125; \"\"\" constant_function_regex3 = re.compile(\"\"\" function\\s*\\w+\\(\\)\\s*\\&#123;\\s* return\\s*[\\'\\\"][^\\'\\\"]*[\\'\\\"];\\s* \\&#125;\\s* \"\"\", re.X) l = constant_function_regex3.findall(js) # print(\"l 206\",l) for i in l: function_name = re.search(\"\"\" function\\s*(\\w+)\\(\\)\\s*\\&#123;\\s* return\\s*[\\'\\\"]([^\\'\\\"]*)[\\'\\\"];\\s* \\&#125;\\s* \"\"\", i, re.X) no_args_return_constant_sample_functions.append(function_name.groups()) js = js.replace(i, \"\") # 替换全文 a, b = function_name.groups() all_var[\"%s()\" % a] = b # 字符串拼接时使无参常量函数 \"\"\" (function() &#123; 'return sZ_'; return '1' &#125;)() \"\"\" constant_function_regex6 = re.compile(\"\"\" \\(function\\(\\)\\s*\\&#123;\\s* [\\'\\\"]return[^\\'\\\"]+[\\'\\\"];\\s* return\\s*[\\'\\\"][^\\'\\\"]*[\\'\\\"];? \\&#125;\\)\\(\\) \"\"\", re.X) l = constant_function_regex6.findall(js) # print(\"l 236\",l) for i in l: function_name = re.search(\"\"\" \\(function\\(\\)\\s*\\&#123;\\s* [\\'\\\"]return[^\\'\\\"]+[\\'\\\"];\\s* return\\s*([\\'\\\"][^\\'\\\"]*[\\'\\\"]);? \\&#125;\\)\\(\\) \"\"\", i, re.X) js = js.replace(i, function_name.group(1)) # 字符串拼接时使用返回参数的函数 \"\"\" (function(iU__) &#123; 'return iU_'; return iU__; &#125;)('9F') \"\"\" constant_function_regex6 = re.compile(\"\"\" \\(function\\(\\w+\\)\\s*\\&#123;\\s* [\\'\\\"]return[^\\'\\\"]+[\\'\\\"];\\s* return\\s*\\w+; \\&#125;\\)\\([\\'\\\"][^\\'\\\"]*[\\'\\\"]\\) \"\"\", re.X) l = constant_function_regex6.findall(js) # print(\"l 264\",l) for i in l: function_name = re.search(\"\"\" \\(function\\(\\w+\\)\\s*\\&#123;\\s* [\\'\\\"]return[^\\'\\\"]+[\\'\\\"];\\s* return\\s*\\w+; \\&#125;\\)\\(([\\'\\\"][^\\'\\\"]*[\\'\\\"])\\) \"\"\", i, re.X) js = js.replace(i, function_name.group(1)) print(\"275\",js) # 获取所有变量 var_regex = \"var\\s+(\\w+)=(.*?);\\s\" var_find = re.findall(var_regex, js) print(\"var_find\",var_find) for var_name, var_value in var_find: var_value = var_value.strip(\"\\'\\\"\").strip() # print(var_name,\"---\",var_value) if \"(\" in var_value: var_value = \";\" all_var[var_name] = var_value print(\"all var\",all_var) # 注释掉 此正则可能会把关键js语句删除掉 # js = re.sub(var_regex, \"\", js) for var_name, var_value in all_var.items(): js = js.replace(var_name, var_value) print(\"----282\",js) js = re.sub(\"[\\s+']\", \"\", js) print(\"----284\",js) string_m = re.search(\"(%\\w\\w(?:%\\w\\w)+)\", js) # string = urllib.parse.unquote(string_m.group(1)).encode(\"utf-8\").decode(\"utf8\") print(\"string_m\",string_m.groups()) string = urllib.parse.unquote(string_m.group(1)).encode(\"utf-8\").decode(\"utf8\") print(string) index_m = re.search(\"([\\d,]+(;[\\d,]+)+)\", js[string_m.end():]) print(index_m.group()) string_list = list(string) print(\"str\",len(string_list)) # print(\"string_list\",string_list) index_list = index_m.group(1).split(\";\") # print(\"index_list\",index_list) _word_list = [] # print(type(_word_list)) # print(_word_list) i = 1 exflag = 0; # deal exception # print(\"--max \",type(int(max(index_list)))) max_index=0; for word_index_list in index_list: _word = \"\" if \",\" in word_index_list: word_index_list = word_index_list.split(\",\") word_index_list = [int(x) for x in word_index_list] else: word_index_list = [int(word_index_list)] for word_index in word_index_list: # print(word_index) if(word_index&gt;max_index): max_index=word_index try: string_list[word_index] except Exception as e: exflag=1; print(max_index) print(\"exflag\",exflag) less = max_index - len(string_list) print(less) for word_index_list in index_list: _word = \"\" if \",\" in word_index_list: word_index_list = word_index_list.split(\",\") # print(\"word_index_list\",word_index_list) word_index_list = [int(x) for x in word_index_list] # print(\"word_index_list\", word_index_list) else: word_index_list = [int(word_index_list)] j = 1; for word_index in word_index_list: # print(\"for\",j) j += 1 # print(\"word_index\",word_index) # print(\"string_list[word_index]\",string_list[word_index]) try: _word += string_list[word_index-1-less] except Exception as e: print(e) # print(_word) _word_list.append(_word) # print(\"----------\") # print(i) # print(_word_list) i += 1 return _word_listdef get_complete_text_autohome(text): #print(\"text0\",text) text = text.replace(r\"\\u0027\",\"'\").replace(r\"\\u003e\",\"&gt;\").replace(r\"\\u003c\",\"&lt;\") #print(\"text1\",text) js = re.search(\"&lt;!--@HS_ZY@--&gt;&lt;script&gt;([\\s\\S]+)\\(document\\);&lt;/script&gt;\", text) #print(\"find : %s\" % js.group()) if not js: print(\" if not js:\") return text try: #print(\"try0\") char_list = get_char(js.group(1)) print(\"try111\") except Exception as e: print(e) print(\"except222\") return text def char_replace(m): index = int(m.group(1)) char = char_list[index] return char text = re.sub(\"&lt;span\\s*class=[\\'\\\"]hs_kw(\\d+)_[^\\'\\\"]+[\\'\\\"]&gt;&lt;/span&gt;\", char_replace, text) # print(text) return text# resp = requests.get(\"http://k.autohome.com.cn/FrontAPI/GetFeelingByEvalId?evalId=1538569\")resp = requests.get(\"http://k.autohome.com.cn/FrontAPI/GetFeelingByEvalId?evalId=1585634\")resp.encoding = \"gbk\"text = get_complete_text_autohome(resp.text)print(re.search(\"&lt;!--@HS_BASE64@--&gt;.*&lt;!--@HS_ZY@--&gt;\", text).group())print(\"2\")# print(re.search(\"&lt;div\\s*class=[\\'\\\"]text-con[^\\'\\\"]*?[\\'\\\"]&gt;([\\s\\S]+?)&lt;/div&gt;\", text).group(1)) 前一个函数是核心，用于解析js 3.爬虫框架3.1 获取所有车型的id首先利用爬虫软件爬取了 汽车列表 里面的所有汽车id，用两层循环爬取所有页面的评论： 123456# 两层遍历，分别遍历车型和页数 for i in car_id_list: # i代表从车型的遍历 for j in range(1,101): # j代表评论页数，range(1,3)表示1到2页 req = scrapy.Request(\"http://k.autohome.com.cn/\"+str(i)+\"/index_\"+str(j)+\".html#dataList\") reqs.append(req) return reqs 3.2本爬虫采用scrapy框架，分析所需要的评论信息为：123456789101112131415161718192021222324252627282930313233343536373839404142434445# 车ID CAR_ID = scrapy.Field() # 车名 CAR_NAME = scrapy.Field() # 用户ID USER_ID = scrapy.Field() # 用户名 USER_NAME = scrapy.Field() # 购买地点 PURCHASE_PLACE = scrapy.Field() # 购买时间 PURCHASE_TIME = scrapy.Field() # 裸车购买价 CAR_PRICE = scrapy.Field() # 购车目的 PURCHASE_PURPOSE = scrapy.Field() # 评分- 空间 SCORE_SPACE = scrapy.Field() # 评分- 动力 SCORE_POWER = scrapy.Field() # 评分- 操控 SCORE_CONTROL = scrapy.Field() # 评分- 油耗 SCORE_FUEL_CONSUMPTION = scrapy.Field() # 评分- 舒适性 SCORE_COMFORT = scrapy.Field() # 评分- 外观 SCORE_EXTERIOR = scrapy.Field() # 评分- 内饰 SCORE_INTERIOR = scrapy.Field() # 评分- 性价比 SCORE_COST_EFFECTIVE = scrapy.Field() # 评论的url COMMENT_URL = scrapy.Field() # 评论的内容 COMMENT_CONTENT = scrapy.Field() # 有多少人支持这条口碑 COMMENT_SUPPORT_QUANTITY = scrapy.Field() # 有多少人看过这条口碑 COMMENT_SEEN_QUANTITY = scrapy.Field() 将其写进item中。 3.3将常用设置写入sttings中1234567891011# 绕过robots.txtROBOTSTXT_OBEY = False#记录日志LOG_FILE = \"scrapy_autohome_log.log\"# 保存文件编码类型FEED_EXPORT_ENCODING = 'GBK'# 伪装chromeUSER_AGENT = 'Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36' 这样利用我们前面学习的scrapy框架的知识，再加上破解的js。我们成功爬取了汽车之家的数据。经过试验爬取了 将近22万条评论。 4.结果展示1.数据条数： 2.数据格式 3.完整代码参见我饿github：https://github.com/xqtbox/AutoHomeSpider_Scrapy","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"汽车之家","slug":"汽车之家","permalink":"http://yoursite.com/tags/汽车之家/"}]},{"title":"AttributeError:FeedExporter object has no attribute slot","slug":"AttributeError:FeedExporter object has no attribute slot","date":"2017-05-20T04:07:04.000Z","updated":"2018-01-23T05:16:03.349Z","comments":true,"path":"2017/05/20/AttributeError:FeedExporter object has no attribute slot/","link":"","permalink":"http://yoursite.com/2017/05/20/AttributeError:FeedExporter object has no attribute slot/","excerpt":"使用scrapy时候你报错： AttributeError: ‘FeedExporter’ object has no attribute ‘slot’ 因为当前需要写入的文件被占用，写不进去！ 解决方法，关闭打开的 csv文件","text":"使用scrapy时候你报错： AttributeError: ‘FeedExporter’ object has no attribute ‘slot’ 因为当前需要写入的文件被占用，写不进去！ 解决方法，关闭打开的 csv文件","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/爬虫/"}],"tags":[{"name":"报错","slug":"报错","permalink":"http://yoursite.com/tags/报错/"},{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"scrapy","slug":"scrapy","permalink":"http://yoursite.com/tags/scrapy/"}]},{"title":"实战天猫数据爬取","slug":"实战天猫数据爬取","date":"2017-05-19T13:34:04.000Z","updated":"2018-01-23T05:24:08.453Z","comments":true,"path":"2017/05/19/实战天猫数据爬取/","link":"","permalink":"http://yoursite.com/2017/05/19/实战天猫数据爬取/","excerpt":"主要用到的知识点 实用技巧1—多级页面的抓取-callback函数 实用技巧2—图片的抓取- 抓取过程中的常见问题—cookie的处理,cookie模拟登录 分页","text":"主要用到的知识点 实用技巧1—多级页面的抓取-callback函数 实用技巧2—图片的抓取- 抓取过程中的常见问题—cookie的处理,cookie模拟登录 分页 1. 实用技巧1—多级页面的抓取-callback函数1yield scrapy.Request(url=item[&quot;GOODS_URL&quot;], meta=&#123;&apos;item&apos;: item&#125;, callback=self.parse_detail,dont_filter=True) 返回的是一个请求，参数为： 123url为进一步处理的地址。meta为了进一步把对象传进去callback是指处理的函数 2. 实用技巧2—图片的抓取-1.首先把图片地址获取 12345678# 图片链接 try: file_urls = div.xpath(&apos;div[@class=&quot;productImg-wrap&quot;]/a[1]/img/@src|&apos; &apos;div[@class=&quot;productImg-wrap&quot;]/a[1]/img/@data-ks-lazyload&apos;).extract()[0] item[&apos;file_urls&apos;] = [&quot;http:&quot; + file_urls] except Exception as e: print(&quot;Error:&quot;,e) import pdb;pdb.set_trace() 2.在settings中引入引擎 123456# 以下三行引入默认的图片下载器，想改可以重写它ITEM_PIPELINES = &#123;&apos;scrapy.pipelines.images.ImagesPipeline&apos;: 1&#125;# 引入items的连接属性IMAGES_URLS_FIELD = &apos;file_urls&apos;# 设置存入本地的地址，当前目录。IMAGES_STORE = r&apos;./images&apos; 3. 抓取过程中的常见问题—cookie的处理,cookie模拟登录自己登录后，查看cookie，把cookie里面的所有参数都输入。 12345678910111213141516171819202122232425def start_requests(self): # 循环页码，就在这个函数中实现。 reqs = [] # 每个页面的request cookies = &#123; &apos;miid&apos;:&apos;1279809970704864021&apos;, &apos;thw&apos;:&apos;cn&apos;, &apos;t&apos;:&apos;7349beda1fac2771e1b07173a388c1a7&apos;, &apos;cookie2&apos;:&apos;169e58df275871365bf763a04f83945d&apos;, &apos;_tb_token_&apos;:&apos;f5836335bbbed&apos;, &apos;l&apos;:&apos;As7Ol7pcpNOglmJtnYezXP/Fnq6RuZJB&apos;, &apos;isg&apos;:&apos;AuTkU7_eYUo5n5WHgkykUP1IteI6RAjnXtEpK_4Ehq96qYZzJ431dp1BH7ZL&apos;, &apos;cna&apos;:&apos;xxqjEU4BaTMCAXLV6R/2cfxq&apos;, &apos;sca&apos;:&apos;49d5174e&apos;, &apos;atpsida&apos;:&apos;b8147f8d3acd3709988ab26d_1495089785_1&apos;, &apos;aimx&apos;:&apos;xxqjEYvEdQcCAXLV6R9iOoQn_1495089785&apos;, &apos;cad&apos;:&apos;k95WugY3Sgew+2KIuDSUxTOnySH07xok1SSfrDICn3k=0001&apos;, &apos;cap&apos;:&apos;41cf&apos;, &apos;_med&apos;:&apos;dw:1366&amp;dh:768&amp;pw:1366&amp;ph:768&amp;ist:0&apos;, &apos;res&apos;:&apos;scroll%3A1349*6611-client%3A1349*637-offset%3A1349*6611-screen%3A1366*768&apos;, &apos;pnm_cku822&apos;:&apos;043UW5TcyMNYQwiAiwQRHhBfEF8QXtHcklnMWc%3D%7CUm5Ockt%2FR3pPe0F5QndJdCI%3D%7CU2xMHDJ7G2AHYg8hAS8XIgwsAl4%2FWTVSLFZ4Lng%3D%7CVGhXd1llXGhQbVhsVm5VYF5jVGlLcEx2SHxBf0F0QH5AekF%2FQG44%7CVWldfS0RMQ01DDQUKBMzHWxSPAIrFioSKhI4Az0YLlV7LXs%3D%7CVmhIGCUFOBgkGiMXNww3CzcXKxUuFTUPNAEhHSMYIwM5BjNlMw%3D%3D%7CV25Tbk5zU2xMcEl1VWtTaUlwJg%3D%3D&apos;, &apos;cq&apos;:&apos;ccp%3D1&apos; &#125; for i in range(0, 2): # 代表从0到1页 req = scrapy.Request(&quot;https://list.tmall.com/search_product.htm?spm=a220m.1000858.0.0.wH40GN&amp;s=&quot;+str(i*60)+&quot;&amp;q=%C4%D0%D7%B0&amp;sort=d&amp;style=g&amp;from=nanzhuang..pc_1_suggest&amp;suggest=0_1&amp;type=pc#J_Filter&quot;,cookies=cookies ) reqs.append(req) return reqs 4. 分页123456789def start_requests(self): # 循环页码，就在这个函数中实现。 reqs = [] # 每个页面的request cookies = &#123; &apos;miid&apos;:&apos;1279809970704864021&apos;, &#125; for i in range(0, 2): # 代表从0到1页 req = scrapy.Request(&quot;https://list.tmall.com/search_product.htm?spm=a220m.1000858.0.0.wH40GN&amp;s=&quot;+str(i*60)+&quot;&amp;q=%C4%D0%D7%B0&amp;sort=d&amp;style=g&amp;from=nanzhuang..pc_1_suggest&amp;suggest=0_1&amp;type=pc#J_Filter&quot;,cookies=cookies ) reqs.append(req) return reqs 完整代码参见 :githubxqtbox实战天猫数据爬取","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"scrapy的内置服务介绍","slug":"scrapy的内置服务介绍","date":"2017-05-19T08:07:04.000Z","updated":"2018-01-23T05:27:43.389Z","comments":true,"path":"2017/05/19/scrapy的内置服务介绍/","link":"","permalink":"http://yoursite.com/2017/05/19/scrapy的内置服务介绍/","excerpt":"1 logging日志服务logging的等级： logging.CRITICAL - for critical errors (highest severity) logging.ERROR - for regular errors logging.WARNING - for warning messages logging.INFO - for informational messages logging.DEBUG - for debugging messages (lowest severity)基本使用方法 三种基本使用方法：","text":"1 logging日志服务logging的等级： logging.CRITICAL - for critical errors (highest severity) logging.ERROR - for regular errors logging.WARNING - for warning messages logging.INFO - for informational messages logging.DEBUG - for debugging messages (lowest severity)基本使用方法 三种基本使用方法： 1234567891011121314# 1.简单使用import logginglogging.warning(&quot;this is a warning&quot;)# 2.通用的记录日志的方法，可加入日志的级别import logginglogging.log(logging.WARNING,&quot;this is a warning&quot;)# 3.通过logger记录日志import logginglogger = logging.getLogger(__name__)logger.warning(&quot;this is a warning&quot;) 在scrapy中使用 在spider中直接使用 123456789import scrapyclass MySpider(scrapy.Spider): # 因为MySpider继承了scrapy.Spider，所以自带了logger name = &apos;myspider&apos; start_urls = [&apos;http://scrapinghub.com&apos;] def parse(self, response): self.logger.info(&apos;Parse function called on %s&apos;, response.url) 可以自己改名字 123456789101112import loggingimport scrapylogger = logging.getLogger(&apos;mycustomlogger&apos;) # 给自己的logger取名字为mycustomloggerclass MySpider(scrapy.Spider): name = &apos;myspider&apos; start_urls = [&apos;http://scrapinghub.com&apos;] def parse(self, response): logger.info(&apos;Parse function called on %s&apos;, response.url) 在settings.py中配置These settings can be used to configure the logging: LOG_FILE LOG_ENABLED LOG_ENCODING LOG_LEVEL LOG_FORMAT LOG_DATEFORMAT LOG_STDOUT stats collectionsScrapy提供了方便的收集数据的机制。数据以key/value方式存储，值大多是计数值。该机制叫做数据收集器(Stats Collector)。 通过 stats 属性来使用数据收集器。 下面是在扩展中使用状态的例子: 基本操作12345678class ExtensionThatAccessStats(object): def __init__(self, stats): self.stats = stats @classmethod def from_crawler(cls, crawler): return cls(crawler.stats) 设置数据: 1stats.set_value(&apos;hostname&apos;, socket.gethostname()) 增加数据值: 1stats.inc_value(&apos;pages_crawled&apos;) 当新的值比原来的值大时设置数据: 1stats.max_value(&apos;max_items_scraped&apos;, value) 当新的值比原来的值小时设置数据: 1stats.min_value(&apos;min_free_memory_percent&apos;, value) 获取数据: 12&gt;&gt;&gt; stats.get_value(&apos;pages_crawled&apos;)8 获取所有数据: 12&gt;&gt;&gt; stats.get_stats()&#123;&apos;pages_crawled&apos;: 1238, &apos;start_time&apos;: datetime.datetime(2009, 7, 14, 21, 47, 28, 977139)&#125; 内置可用收集器12345# 记录内存的只能在linux中使用class scrapy.statscollectors.MemoryStatsCollector # 信息清道收集器class scrapy.statscollectors.DummyStatsCollector sending-email虽然Python通过 smtplib 库使得发送email变得很简单，Scrapy仍然提供了自己的实现。 该功能十分易用，同时由于采用了 Twisted非阻塞式(non-blocking)IO ，其避免了对爬虫的非阻塞式IO的影响。 另外，其也提供了简单的API来发送附件。 通过一些 settings 设置，您可以很简单的进行配置。 基本使用方法有两种方法可以创建邮件发送器(mail sender)。 您可以通过标准构造器(constructor)创建: 12from scrapy.mail import MailSendermailer = MailSender() 或者您可以传递一个Scrapy设置对象，其会参考 settings:1mailer = MailSender.from_settings(settings) 这是如何来发送邮件了(不包括附件): 1mailer.send(to=[&quot;someone@example.com&quot;], subject=&quot;Some subject&quot;, body=&quot;Some body&quot;, cc=[&quot;another@example.com&quot;]) mailsender类初始化参数： 1class scrapy.mail.MailSender(smtphost=None, mailfrom=None, smtpuser=None, smtppass=None, smtpport=None) 参数: 1234567smtphost (str) – 发送email的SMTP主机(host)。如果忽略，则使用 MAIL_HOST 。mailfrom (str) – 用于发送email的地址(address)(填入 From:) 。 如果忽略，则使用 MAIL_FROM 。smtpuser – SMTP用户。如果忽略,则使用 MAIL_USER 。 如果未给定，则将不会进行SMTP认证(authentication)。smtppass (str) – SMTP认证的密码smtpport (int) – SMTP连接的短裤smtptls – 强制使用STARTTLSsmtpssl (boolean) – 强制使用SSL连接 123456classmethod from_settings(settings)使用Scrapy设置对象来初始化对象。其会参考 这些Scrapy设置.send(to, subject, body, cc=None, attachs=(), mimetype=&apos;text/plain&apos;)发送email到给定的接收者。 mail settings这些设置定义了 MailSender 构造器的默认值。其使得在您不编写任何一行代码的情况下，为您的项目配置实现email通知的功能。 123456789101112131415161718192021222324252627MAIL_FROM默认值: &apos;scrapy@localhost&apos;用于发送email的地址(address)(填入 From:) 。MAIL_HOST默认值: &apos;localhost&apos;发送email的SMTP主机(host)。MAIL_PORT默认值: 25发用邮件的SMTP端口。MAIL_USER默认值: NoneSMTP用户。如果未给定，则将不会进行SMTP认证(authentication)。MAIL_PASS默认值: None用于SMTP认证，与 MAIL_USER 配套的密码。MAIL_TLS默认值: False强制使用STARTTLS。STARTTLS能使得在已经存在的不安全连接上，通过使用SSL/TLS来实现安全连接。MAIL_SSL默认值: False强制使用SSL加密连接。","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"scrapy","slug":"scrapy","permalink":"http://yoursite.com/tags/scrapy/"}]},{"title":"pycharm下打开执行并调试scrapy爬虫程序","slug":"pycharm下打开执行并调试scrapy爬虫程序","date":"2017-05-14T12:07:04.000Z","updated":"2018-01-23T05:35:42.149Z","comments":true,"path":"2017/05/14/pycharm下打开执行并调试scrapy爬虫程序/","link":"","permalink":"http://yoursite.com/2017/05/14/pycharm下打开执行并调试scrapy爬虫程序/","excerpt":"首先得有一个Scrapy项目，我在Desktop上新建一个Scrapy的项目叫test，在Desktop目录打开命令行，键入命令：scrapy startproject test1","text":"首先得有一个Scrapy项目，我在Desktop上新建一个Scrapy的项目叫test，在Desktop目录打开命令行，键入命令：scrapy startproject test1 目录结构如下： 打开Pycharm，选择open 选择项目，ok 打开如下界面之后，按alt + 1， 打开project 面板 在test1/spiders/，文件夹下，新建一个爬虫spider.py， 注意代码中的name=”dmoz”。这个名字后面会用到。 在test1目录和scrapy.cfg同级目录下面，新建一个begin.py文件（便于理解可以写成main.py），注意箭头2所指的名字和第5步中的name=’dmoz’ 名字是一样的。123from scrapy import cmdlinecmdline.execute(&quot;scrapy crawl dmoz&quot;.split()) 上面把文件搞定了，下面要配置一下pycharm了。点击Run-&gt;Edit Configurations 新建一个运行的python模块 Name：改成spider； script：选择刚才新建的那个begin.py文件；Working Direciton：改成自己的工作目录 至此，大功告成了，点击下图，右上角的按钮就能运行了。 调试可以在其他代码中设置断点，就可以debug运行 转载1：http://www.jianshu.com/p/f85120fcbca0 转载2：http://blog.csdn.net/wangsidadehao/article/details/52911746","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"scrapy","slug":"scrapy","permalink":"http://yoursite.com/tags/scrapy/"},{"name":"Pycharm","slug":"Pycharm","permalink":"http://yoursite.com/tags/Pycharm/"}]},{"title":"scrapy的重要对象request和response","slug":"scrapy的重要对象request和response","date":"2017-05-13T09:07:04.000Z","updated":"2018-01-23T05:39:15.781Z","comments":true,"path":"2017/05/13/scrapy的重要对象request和response/","link":"","permalink":"http://yoursite.com/2017/05/13/scrapy的重要对象request和response/","excerpt":"scrapy的重要对象 web服务器收到客户端的HTTP请求，会针对每一次请求分别创建一个用于代表请求的request对象和代表响应的response对象。 要得到客户机提交过来的数据，只需要找request对象就行了。 要向客户机输出数据，只需要找response对象就行了。","text":"scrapy的重要对象 web服务器收到客户端的HTTP请求，会针对每一次请求分别创建一个用于代表请求的request对象和代表响应的response对象。 要得到客户机提交过来的数据，只需要找request对象就行了。 要向客户机输出数据，只需要找response对象就行了。 1.requests1.1初始化的参数12345678910class scrapy.http.Request(url [ , callback, method=&apos;GET&apos;,headers, body,cookies, meta,encoding=&apos;utf-8&apos;, priority=0, don&apos;t_filter=False, errback ] ) 1.2属性12345678910111213141516url method headers body meta copy() 复制一个相同的request replace()### 1.3实例1，生成Request的方法 def parse_page1(self, response): return scrapy.Request(“http://www.example.com/some_page.html“, callback=self.parse_page2) def parse_page2(self, response): # this would log http://www.example.com/some_page.html self.logger.info(&quot;Visited %s&quot;, response.url) 12342，通过Request传递数据的方法在两个不同的解析函数之间传递数据的方法。 def parse_page1(self, response): item = MyItem() item[‘main_url’] = response.url request = scrapy.Request(“http://www.example.com/some_page.html“, callback=self.parse_page2) request.meta[‘item’] = item return request def parse_page2(self, response): item = response.meta[‘item’] item[‘other_url’] = response.url return item1234567891011 3 Request.meta中的特殊关键字 ### 1.4子类主要的子类是FormRequest。主要用来“登录”作用。所以非常重要。 1,新参数: formdata #用于存储用户名，密码等数据 2,新的类方法: from_reponse # 从一个reponse中生成一个request 1234#### 实例：使用FormRequest.from_response()方法模拟用户登录通常网站通过 &lt;input type=&quot;hidden&quot;&gt; 实现对某些表单字段（如数据或是登录界面中的认证令牌等）的预填充。 使用Scrapy抓取网页时，如果想要预填充或重写像用户名、用户密码这些表单字段， 可以使用 FormRequest.from_response() 方法实现。下面是使用这种方法的爬虫例子: import scrapy class LoginSpider(scrapy.Spider): name = ‘example.com’ start_urls = [‘http://www.example.com/users/login.php‘] def parse(self, response): return scrapy.FormRequest.from_response( # 从respongse返回一个request（FormRequest） response, formdata={&apos;username&apos;: &apos;john&apos;, &apos;password&apos;: &apos;secret&apos;}, callback=self.after_login ) def after_login(self, response): # check login succeed before going on if &quot;authentication failed&quot; in response.body: self.logger.error(&quot;Login failed&quot;) return # continue scraping with authenticated session... 12345678## 2.responsesresponse是scrapy对request的相应，所以是自动产生。一般不用自己生成。### 2.1初始化的参数 class scrapy.http.Response( url [ , status=200, headers, body, flags ] ) 123### 2.2成员属性与方法 url status headers body request # 是产生该response的request meta # 是request.meta的简要形式 flags copy() replace() urljoin() # 经常用到！用相对连接生成绝对连接。 12### 2.3子类 class scrapy.http.TextResponse(url [ , encoding [ , … ]] ) class scrapy.http.HtmlResponse(url [ , … ] ) class scrapy.http.XmlResponse(url [ , … ] )``` 要搞懂的问题1，掌握Request初始化参数的意义，并学会使用；了解Request中的剩余属性和方法 2，掌握通过Request传递数据的方法； 3，掌握FormRequest的用法； 4，掌握Response中属性方法的意义 5，了解Response的子类都有那些，是干什么用的","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"scrapy","slug":"scrapy","permalink":"http://yoursite.com/tags/scrapy/"}]},{"title":"faial:refusing to merge unrelated histories","slug":" faial:refusing to merge unrelated histories","date":"2017-05-03T02:27:24.000Z","updated":"2018-01-23T05:44:53.229Z","comments":true,"path":"2017/05/03/ faial:refusing to merge unrelated histories/","link":"","permalink":"http://yoursite.com/2017/05/03/ faial:refusing to merge unrelated histories/","excerpt":"本文解决在git中遇到的问题： faial: refusing to merge unrelated histories 原因： 在首次提交代码之前，必须首先pull一下。但是因为两个仓库不同，发现refusing to merge unrelated histories，无法pull。","text":"本文解决在git中遇到的问题： faial: refusing to merge unrelated histories 原因： 在首次提交代码之前，必须首先pull一下。但是因为两个仓库不同，发现refusing to merge unrelated histories，无法pull。 这是因为他们是两个不同的项目，要把两个不同的项目合并，git需要添加一句代码，在git pull后面。这句代码是在git 2.9.2版本发生的，最新的版本需要添加--allow-unrelated-histories 解决：所以我们想要pull的时候 ，应该写如下git命令：假如我们的本地源是origin，github上的分支是master，那么我们 需要这样写： git pull origin master --allow-unrelated-histories（一定要注意是两个减号！！！）","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"报错","slug":"报错","permalink":"http://yoursite.com/tags/报错/"}]},{"title":"破解myeclipse10时找不到myeclipse-Common-plusgin","slug":"将本地的项目上传到github上面的方法教程","date":"2017-05-03T02:17:04.000Z","updated":"2018-01-23T05:42:07.749Z","comments":true,"path":"2017/05/03/将本地的项目上传到github上面的方法教程/","link":"","permalink":"http://yoursite.com/2017/05/03/将本地的项目上传到github上面的方法教程/","excerpt":"1.注册账户以及创建仓库要想使用github第一步当然是注册github账号了。之后就可以创建仓库了。步骤如下： 打开https://github.com 直接在首页上注册 点按钮注册成功之后，在页面上方用户菜单上选择 “+”-&gt;New repository 创建一个新的仓库。","text":"1.注册账户以及创建仓库要想使用github第一步当然是注册github账号了。之后就可以创建仓库了。步骤如下： 打开https://github.com 直接在首页上注册 点按钮注册成功之后，在页面上方用户菜单上选择 “+”-&gt;New repository 创建一个新的仓库。 为仓库取一个名字，点击创建仓库按钮 你将成功创建一个仓库。 2.安装git客户端github是服务端，要想在自己电脑上使用git我们还需要一个git客户端， windows用户请下载 http://msysgit.github.com/ mac用户请下载 http://code.google.com/p/tortoisegit/ 一路next，安装成功后， 回到C盘，或任何文件夹下，点鼠标右键会多出一些菜单如 Git Bash、Git Init Hear（新版本消失）、Git Gui ， 说明安装成功。 3.配置Git我们先在电脑硬盘里找一块地方存放本地仓库，比如我们把本地仓库建立在C:\\MyRepository\\1ke_test文件夹下（自己选择文件夹，可以在D盘，推荐在github安装目录下） 进入1ke_test文件夹 鼠标右键操作如下步骤： 1）设定主目录在本地仓库里右键选择Git Bash进入git命令行，截图效果如下： 为了设定此目录为主目录！！我们先执行git init命令（github将以此文件夹为据点） 1$ git init （输入时 去掉$号） 为了把本地的仓库传到github，还需要配置ssh key！！！！用于建立本地到github的连接. 2）在本地创建ssh key1$ ssh-keygen -t rsa -C &quot;your_email@youremail.com&quot; 后面的your_email@youremail.com改为你的邮箱。我的邮箱是lilu@1ke.co，也是在github上注册的那个邮箱： 直接点回车，说明会在默认文件id_rsa上生成ssh key。 然后系统要求输入密码，直接按回车表示不设密码 重复密码时也是直接回车，之后提示你shh key已经生成成功。 然后我们进入提示的地址下查看ssh key文件。 我的电脑的地址是C:\\Users\\lilu\\.ssh ，其中lilu是我的电脑的名称 打开id_rsa.pub，复制里面的key。里面的key是一对看不懂的字符数字组合，不用管它，直接复制。 回到github网站，进入Account Settings，左边选择SSH Keys，Add SSH Key, title随便填，粘贴key。 3）验证是否成功在git bash下输入 1$ ssh -T git@github.com 回车就会看到：You’ve successfully authenticated, but GitHub does not provide shell access 。这就表示已成功连上github。 4）设置username和email接下来我们要做的就是把本地仓库传到github上去，在此之前还需要设置username和email，因为github每次commit都会记录他们。 12$ git config --global user.name &quot;your name&quot;$ git config --global user.email &quot;your_email@youremail.com&quot; 分别输入上述命令行 回车， 我的界面显示如下 5）连接本地与github进入要上传的仓库，右键git bash，添加远程地址 1$ git remote add origin git@github.com:yourName/yourRepo.git 后面的yourName和yourRepo表示你再github的用户名和刚才新建的仓库，加完之后进入.git，打开config，这里会多出一个remote “origin”内容，这就是刚才添加的远程地址，也可以直接修改config来配置远程地址。 与github上的对应 4.提交上传1）在本地仓库添加一些文件接下来在本地仓库里添加一些文件，比如README 在本地新建一个README文件（或者复制你的代码项目） 2）上传到本地缓存服务器在命令行输入一下命令 123$ git add README$ git commit -m &quot;first commit&quot; 执行界面如下 3）上传到github如果这是第一次上传（push）到github的这个项目里。 上传之前，需要先将github上已有数据的拉取到本地，这样才能比较你上传过后的与之前的数据的区别。 1)拉取（pull）服务器数据指令：1git pull origin master --allow-unrelated-histories 此时，我们发现，将服务器上的readme给下载下来了。正和我们意。 2) 上传到github指令： 1$ git push origin master git push命令会将本地仓库推送到远程服务器。 git pull命令则相反。 5.常用Git命令查看、添加、提交、删除、找回，重置修改文件 1234567891011121314151617181920212223242526272829git help &lt;command&gt; # 显示command的helpgit show # 显示某次提交的内容 git show $idgit co -- &lt;file&gt; # 抛弃工作区修改git co . # 抛弃工作区修改git add &lt;file&gt; # 将工作文件修改提交到本地暂存区git add . # 将所有修改过的工作文件提交暂存区git rm &lt;file&gt; # 从版本库中删除文件git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除文件git reset &lt;file&gt; # 从暂存区恢复到工作文件git reset -- . # 从暂存区恢复到工作文件git reset --hard # 恢复最近一次提交过的状态，即放弃上次提交后的所有本次修改git ci &lt;file&gt; git ci . git ci -a # 将git add, git rm和git ci等操作都合并在一起做 git ci -am &quot;some comments&quot;git ci --amend # 修改最后一次提交记录git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交对象git revert HEAD # 恢复最后一次提交的状态 查看文件diff 1234567891011git diff &lt;file&gt; # 比较当前文件和暂存区文件差异 git diffgit diff &lt;id1&gt;&lt;id2&gt; # 比较两次提交之间的差异git diff &lt;branch1&gt;..&lt;branch2&gt; # 在两个分支之间比较git diff --staged # 比较暂存区和版本库差异git diff --cached # 比较暂存区和版本库差异git diff --stat # 仅仅比较统计信息 查看提交记录 1234567git log git log &lt;file&gt; # 查看该文件每次提交记录git log -p &lt;file&gt; # 查看每次详细修改内容的diffgit log -p -2 # 查看最近两次详细修改内容的diffgit log --stat #查看提交统计信息 tig Mac上可以使用tig代替diff和log，brew install tig Git 本地分支管理查看、切换、创建和删除分支 1234567891011121314151617181920212223git br -r # 查看远程分支git br &lt;new_branch&gt; # 创建新的分支git br -v # 查看各个分支最后提交信息git br --merged # 查看已经被合并到当前分支的分支git br --no-merged # 查看尚未被合并到当前分支的分支git co &lt;branch&gt; # 切换到某个分支git co -b &lt;new_branch&gt; # 创建新的分支，并且切换过去git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于branch创建新的new_branchgit co $id # 把某次历史提交记录checkout出来，但无分支信息，切换到其他分支会自动删除git co $id -b &lt;new_branch&gt; # 把某次历史提交记录checkout出来，创建成一个分支git br -d &lt;branch&gt; # 删除某个分支git br -D &lt;branch&gt; # 强制删除某个分支 (未被合并的分支被删除的时候需要强制) 分支合并和rebase 12345git merge &lt;branch&gt; # 将branch分支合并到当前分支git merge origin/master --no-ff # 不要Fast-Foward合并，这样可以生成merge提交git rebase master &lt;branch&gt; # 将master rebase到branch，相当于： git co &lt;branch&gt; &amp;&amp; git rebase master &amp;&amp; git co master &amp;&amp; git merge &lt;branch&gt; Git补丁管理(方便在多台机器上开发同步时用) 12345git diff &gt; ../sync.patch # 生成补丁git apply ../sync.patch # 打补丁git apply --check ../sync.patch #测试补丁能否成功 Git暂存管理123456789101112131415161718192021git stash # 暂存git stash list # 列所有stashgit stash apply # 恢复暂存的内容git stash drop # 删除暂存区Git远程分支管理git pull # 抓取远程仓库所有分支更新并合并到本地git pull --no-ff # 抓取远程仓库所有分支更新并合并到本地，不要快进合并git fetch origin # 抓取远程仓库更新git merge origin/master # 将远程主分支合并到本地当前分支git co --track origin/branch # 跟踪某个远程分支创建相应的本地分支git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支，功能同上 git push # push所有分支 123456789git push origin master # 将本地主分支推到远程主分支git push -u origin master # 将本地主分支推到远程(如无远程主分支则创建，用于初始化远程仓库)git push origin &lt;local_branch&gt; # 创建远程分支， origin是远程仓库名git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支git push origin :&lt;remote_branch&gt; #先删除本地分支(git br -d &lt;branch&gt;)，然后再push删除远程分支 Git远程仓库管理 1234567git remote -v # 查看远程服务器地址和仓库名称git remote show origin # 查看远程服务器仓库状态git remote add origin git@ github:robbin/robbin_site.git # 添加远程仓库地址git remote set-url origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址(用于修改远程仓库地址) git remote rm &lt;repository&gt; # 删除远程仓库 创建远程仓库 12345678910111213git clone --bare robbin_site robbin_site.git # 用带版本的项目创建纯版本仓库scp -r my_project.git git@ git.csdn.net:~ # 将纯仓库上传到服务器上mkdir robbin_site.git &amp;&amp; cd robbin_site.git &amp;&amp; git --bare init # 在服务器创建纯仓库git remote add origin git@ github.com:robbin/robbin_site.git # 设置远程仓库地址git push -u origin master # 客户端首次提交git push -u origin develop # 首次将本地develop分支提交到远程develop分支，并且trackgit remote set-head origin master # 设置远程仓库的HEAD指向master分支 也可以命令设置跟踪远程库和本地库123456789101112git branch --set-upstream master origin/mastergit branch --set-upstream develop origin/develop此文章属转载，原文地址：http://1ke.co/course/194另附： 解决 在使用git 对源代码进行push到gitHub时可能会出错，error: failed to push some refs to git。出现错误的主要原因是github中的README.md文件不在本地代码目录中可以通过如下命令进行github与本地代码合并: git pull --rebase origin master重新执行之前的git push 命令，成功！","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"爬取汽车之家实战","slug":"爬取汽车之家实战","date":"2017-05-01T17:07:04.000Z","updated":"2018-01-23T05:47:50.869Z","comments":true,"path":"2017/05/02/爬取汽车之家实战/","link":"","permalink":"http://yoursite.com/2017/05/02/爬取汽车之家实战/","excerpt":"1. 任务简介 及 爬虫架构极前面学习了，爬虫的基本架构。现在要动手实践了，因为师兄说“学一门语言就必须上手去练习！”。 爬取哪个网站呢？正好，最近需要汽车之家上面的数据， 我就爬这个。本文代码全部共享于GitHub上，地址：爬取汽车之家实战：github 目标：爬取100种汽车的名字，以及网友对它的评分。","text":"1. 任务简介 及 爬虫架构极前面学习了，爬虫的基本架构。现在要动手实践了，因为师兄说“学一门语言就必须上手去练习！”。 爬取哪个网站呢？正好，最近需要汽车之家上面的数据， 我就爬这个。本文代码全部共享于GitHub上，地址：爬取汽车之家实战：github 目标：爬取100种汽车的名字，以及网友对它的评分。 下面开始编程： 在pychram中创建一个工程 在工程中新建一个python包 新建一个main类 创建各个功能类：url管理器、网页下载器、网页解析器、保存获取的信息 下面贴上main类的代码（有详细注释）： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# 加载url管理器、下载器、解析器、输出器from autohome_spider import url_manager, html_downloader, html_parser, html_outputerclass SpiderMain(object): # 初始化各个对象 def __init__(self): self.urls = url_manager.UrlManager() self.downloader = html_downloader.HtmlDownloader() self.parser = html_parser.HtmlParser() self.outputer = html_outputer.HtmlOutputer() def craw(self, root_url): # 记录当前爬取的是第几个url count = 1 # 将入口url添加进url管理器，这样url管理器就有了待爬取的url,我们就可以启动爬虫的循环 self.urls.add_new_url(root_url) # 当url管理器有新的url时，启动循环 while self.urls.has_new_url(): try: # 获取待爬取的url new_url = self.urls.get_new_url() # 实时打印爬取数和爬取url print('craw %s : %s' % (count, new_url)) # 下载器下载页面 html_cont = self.downloader.download(new_url) # print(html_cont) # 解析器解析url和页面，得到新的url和数据(返回两个值) new_urls, new_data = self.parser.parse(new_url, html_cont) # 获得的新的url添加进url管理器 self.urls.add_new_urls(new_urls) # 收集数据 self.outputer.collect_data(new_data) # 设置爬取数 if count == 100: break count = count + 1 except Exception as e: print(str(e)) # 输出收集好的数据 self.outputer.output_html()if __name__ == '__main__': # 爬虫入口url root_url = 'http://www.autohome.com.cn/78/#pvareaid=103177' obj_spider = SpiderMain() obj_spider.craw(root_url) 2. url管理器url管理器存放已经抓取的url和还没抓取的url 123456789101112131415161718192021222324252627282930313233343536class UrlManager(object): # 初始化存放新的url列表和爬取过的url列表 def __init__(self): self.new_urls = set() self.old_urls = set() # 向url管理器添加一个新的url def add_new_url(self, url): # url是否是空 if url is None: return # url是否存在在新的url列表和爬取过的url列表中 if url not in self.new_urls and url not in self.old_urls: self.new_urls.add(url) # 向url管理器添加新的url(urls是 解析器 返回的新的url列表) def add_new_urls(self, urls): # urls是否是空 if urls is None or len(urls) == 0: return # 逐一添加url for url in urls: self.add_new_url(url) # url管理器是否有新的待爬取url def has_new_url(self): return len(self.new_urls) != 0 # 从url管理器中获取新的待爬取url def get_new_url(self): # 获取url并从new_urls中移除 new_url = self.new_urls.pop() # 添加进已爬取old_urls中 self.old_urls.add(new_url) # 返回新的url return new_url 3. 网页下载器网页下载器 将下载所给的url的网页html代码。在这里要特别注意“乱码问题”，解决办法见我另一篇文章–&gt;：Python字符串的encode与decode研究心得——解决乱码问题 代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940from urllib import requestfrom urllib import parse### 使用urllib库进行下载HTML页面class HtmlDownloader(object): def download(self, url): if url is None: return None values = &#123;'name': 'voidking', 'language': 'Python'&#125; data = parse.urlencode(values).encode(encoding='utf-8', errors='ignore') headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0','Content-Length': '0'&#125; request1 = request.Request(url=url, data=data, headers=headers, method='GET') response = request.urlopen(request1) if response.getcode() != 200: return None buff = response.read() html = buff.decode(\"gb2312\",errors='ignore') return htmlfrom urllib import requestfrom urllib import parse### 使用urllib库进行下载HTML页面class HtmlDownloader(object): def download(self, url): if url is None: return None values = &#123;'name': 'voidking', 'language': 'Python'&#125; data = parse.urlencode(values).encode(encoding='utf-8', errors='ignore') headers = &#123;'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; WOW64; rv:50.0) Gecko/20100101 Firefox/50.0','Content-Length': '0'&#125; request1 = request.Request(url=url, data=data, headers=headers, method='GET') response = request.urlopen(request1) if response.getcode() != 200: return None buff = response.read() html = buff.decode(\"gb2312\",errors='ignore') return html 4. 网页解析器网页解析器的主要作用是： 匹配html代码中的所需信息（车名，评分） 找出当前页面中指向另外的车页面的url 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from bs4 import BeautifulSoupimport refrom urllib import parseclass HtmlParser(object): # 获取html中的新的连接 def _get_new_urls(self, page_url, soup): # 结果存入列表 new_urls = set() # 正则匹配：&lt;a href=\"/3589/#pvareaid=101201\" title=\"博瑞\"&gt;博瑞&lt;/a&gt; links = soup.find_all('a', href=re.compile(r'/\\d+/#pvareaid=\\d+'),title=re.compile(r'\\S')) for link in links: # 获取相对url new_url = link['href'] # 拼接为完整url new_full_url = parse.urljoin(page_url, new_url) # print(new_full_url) new_urls.add(new_full_url) # print(new_urls) return new_urls # 获取当前页面 汽车的名字以及评分 def _get_new_data(self, page_url, soup): # 存放数据 res_data = &#123;&#125; # url res_data['url'] = page_url # 获取html中的车名 # &lt;div class=\"subnav-title-name\"&gt; &lt;a href=\"/78/\"&gt;广汽本田-&lt;h1&gt;雅阁&lt;/h1&gt;&lt;/a&gt; &lt;/div&gt; title_node = soup.find( 'div', class_='subnav-title-name').find('a') # 转换成字符串 并去除&lt;h1&gt;标签 res_data['title'] = title_node.get_text().strip('&lt;h1&gt;').strip('&lt;/h1&gt;') # 获取html中的汽车评分 # &lt;a class=\"font-score\" href=\"http://k.autohome.com.cn/78/8369/#pvareaid=101486\"&gt;4.38&lt;/a&gt; summary_node = soup.find('a', class_='font-score') res_data['summary'] = summary_node.get_text() print(res_data) return res_data def parse(self, page_url, html_cont): if page_url is None or html_cont is None: return soup = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8') soup2 = BeautifulSoup(html_cont, 'html.parser', from_encoding='utf-8') new_urls = self._get_new_urls(page_url, soup) new_data = self._get_new_data(page_url, soup2) return new_urls, new_data 5. 保存获取的信息这个类用于保存获取的信息，将所需要的信息保存为一个页面，便于查看。如下图： 代码如下： 1234567891011121314151617181920212223242526272829303132333435class HtmlOutputer(object): def __init__(self): self.datas = [] def collect_data(self, data): if data is None: return self.datas.append(data) def output_html(self): # 在windows下新文件的默认编码是gbk，需手动改为utf-8 fout = open('output.html', 'w', encoding='utf-8') fout.write('&lt;html&gt;') fout.write('&lt;body&gt;') fout.write('&lt;table&gt;') # 表头 fout.write('&lt;tr&gt;') fout.write('&lt;td&gt;公司-车名&lt;/td&gt;') fout.write('&lt;td&gt;网友评分&lt;/td&gt;') fout.write('&lt;/tr&gt;') for data in self.datas: fout.write('&lt;tr&gt;') # fout.write('&lt;td&gt;%s&lt;/td&gt;' % data['url']) fout.write('&lt;td&gt;%s&lt;/td&gt;' % data['title']) fout.write('&lt;td&gt; %s&lt;/td&gt;' % data['summary']) fout.write('&lt;/tr&gt;') fout.write('&lt;/table&gt;') fout.write('&lt;/body&gt;') fout.write('&lt;/html&gt;') fout.close()","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"scrapy","slug":"scrapy","permalink":"http://yoursite.com/tags/scrapy/"},{"name":"汽车之家","slug":"汽车之家","permalink":"http://yoursite.com/tags/汽车之家/"}]},{"title":"Python3 面向对象","slug":"Python3 面向对象","date":"2017-05-01T13:07:04.000Z","updated":"2018-01-23T05:21:30.657Z","comments":true,"path":"2017/05/01/Python3 面向对象/","link":"","permalink":"http://yoursite.com/2017/05/01/Python3 面向对象/","excerpt":"Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。 如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。 接下来我们先来简单的了解下面向对象的一些基本特征。","text":"Python从设计之初就已经是一门面向对象的语言，正因为如此，在Python中创建一个类和对象是很容易的。本章节我们将详细介绍Python的面向对象编程。 如果你以前没有接触过面向对象的编程语言，那你可能需要先了解一些面向对象语言的一些基本特征，在头脑里头形成一个基本的面向对象的概念，这样有助于你更容易的学习Python的面向对象编程。 接下来我们先来简单的了解下面向对象的一些基本特征。 1.面向对象技术简介类(Class): 用来描述具有相同的属性和方法的对象的集合。它定义了该集合中每个对象所共有的属性和方法。对象是类的实例。 类变量：类变量在整个实例化的对象中是公用的。类变量定义在类中且在函数体之外。类变量通常不作为实例变量使用。 数据成员：类变量或者实例变量用于处理类及其实例对象的相关的数据。 方法重写：如果从父类继承的方法不能满足子类的需求，可以对其进行改写，这个过程叫方法的覆盖（override），也称为方法的重写。 实例变量：定义在方法中的变量，只作用于当前实例的类。 继承：即一个派生类（derived class）继承基类（base class）的字段和方法。继承也允许把一个派生类的对象作为一个基类对象对待。例如，有这样一个设计：一个Dog类型的对象派生自Animal类，这是模拟”是一个（is-a）”关系（例图，Dog是一个Animal）。 实例化：创建一个类的实例，类的具体对象。 方法：类中定义的函数。 对象：通过类定义的数据结构实例。对象包括两个数据成员（类变量和实例变量）和方法。 和其它编程语言相比，Python 在尽可能不增加新的语法和语义的情况下加入了类机制。 Python中的类提供了面向对象编程的所有基本功能：类的继承机制允许多个基类，派生类可以覆盖基类中的任何方法，方法中可以调用基类中的同名方法。 对象可以包含任意数量和类型的数据。 2.类定义语法格式如下： 123456class ClassName: &lt;statement-1&gt; . . . &lt;statement-N&gt; 类实例化后，可以使用其属性，实际上，创建一个类之后，可以通过类名访问其属性。 2.类对象类对象支持两种操作：属性引用和实例化。 属性引用使用和 Python 中所有的属性引用一样的标准语法：obj.name。 类对象创建后，类命名空间中所有的命名都是有效属性名。所以如果类定义是这样: 1234567891011121314#!/usr/bin/python3class MyClass: &quot;&quot;&quot;一个简单的类实例&quot;&quot;&quot; i = 12345 def f(self): return &apos;hello world&apos;# 实例化类x = MyClass()# 访问类的属性和方法print(&quot;MyClass 类的属性 i 为：&quot;, x.i)print(&quot;MyClass 类的方法 f 输出为：&quot;, x.f()) 以上程序输出结果为：12MyClass 类的属性 i 为： 12345MyClass 类的方法 f 输出为： hello world 很多类都倾向于将对象创建为有初始状态的。因此类可能会定义一个名为 __init__() 的特殊方法（构造方法），像下面这样：12def __init__(self): self.data = [] 当然， __init__() 方法可以有参数，参数通过 __init__() 传递到类的实例化操作上。例如:12345678&gt;&gt;&gt; class Complex:... def __init__(self, realpart, imagpart):... self.r = realpart... self.i = imagpart...&gt;&gt;&gt; x = Complex(3.0, -4.5)&gt;&gt;&gt; x.r, x.i(3.0, -4.5) self代表类的实例，而非类类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是 self。 1234567class Test: def prt(self): print(self) print(self.__class__) t = Test()t.prt() 以上实例执行结果为： 12&lt;__main__.Test instance at 0x100771878&gt;__main__.Test 从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 self.class 则指向类。 4.类的方法在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数: 1234567891011121314151617181920#!/usr/bin/python3#类定义class people: #定义基本属性 name = &apos;&apos; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))# 实例化类p = people(&apos;runoob&apos;,10,30)p.speak() 执行以上程序输出结果为：1runoob 说: 我 10 岁。 5.继承Python 同样支持类的继承，如果一种语言不支持继承，类就没有什么意义。派生类的定义如下所示: 需要注意圆括号中基类的顺序，若是基类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找基类中是否包含方法。BaseClassName（示例中的基类名）必须与派生类定义在一个作用域内。除了类，还可以用表达式，基类定义在另一个模块中时这一点非常有用: 1234567891011121314151617181920212223242526272829303132#!/usr/bin/python3#类定义class people: #定义基本属性 name = &apos;&apos; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))#单继承示例class student(people): grade = &apos;&apos; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))s = student(&apos;ken&apos;,10,60,3)s.speak() 执行以上程序输出结果为：1ken 说: 我 10 岁了，我在读 3 年级 多继承Python同样有限的支持多继承形式。多继承的类定义形如下例: 需要注意圆括号中父类的顺序，若是父类中有相同的方法名，而在子类使用时未指定，python从左至右搜索 即方法在子类中未找到时，从左到右查找父类中是否包含方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#!/usr/bin/python3#类定义class people: #定义基本属性 name = &apos;&apos; age = 0 #定义私有属性,私有属性在类外部无法直接进行访问 __weight = 0 #定义构造方法 def __init__(self,n,a,w): self.name = n self.age = a self.__weight = w def speak(self): print(&quot;%s 说: 我 %d 岁。&quot; %(self.name,self.age))#单继承示例class student(people): grade = &apos;&apos; def __init__(self,n,a,w,g): #调用父类的构函 people.__init__(self,n,a,w) self.grade = g #覆写父类的方法 def speak(self): print(&quot;%s 说: 我 %d 岁了，我在读 %d 年级&quot;%(self.name,self.age,self.grade))#另一个类，多重继承之前的准备class speaker(): topic = &apos;&apos; name = &apos;&apos; def __init__(self,n,t): self.name = n self.topic = t def speak(self): print(&quot;我叫 %s，我是一个演说家，我演讲的主题是 %s&quot;%(self.name,self.topic))#多重继承class sample(speaker,student): a =&apos;&apos; def __init__(self,n,a,w,g,t): student.__init__(self,n,a,w,g) speaker.__init__(self,n,t)test = sample(&quot;Tim&quot;,25,80,4,&quot;Python&quot;)test.speak() #方法名同，默认调用的是在括号中排前地父类的方法 执行以上程序输出结果为：1我叫 Tim，我是一个演说家，我演讲的主题是 Python 6.方法重写如果你的父类方法的功能不能满足你的需求，你可以在子类重写你父类的方法，实例如下： 123456789101112#!/usr/bin/python3class Parent: # 定义父类 def myMethod(self): print (&apos;调用父类方法&apos;)class Child(Parent): # 定义子类 def myMethod(self): print (&apos;调用子类方法&apos;)c = Child() # 子类实例c.myMethod() # 子类调用重写方法 执行以上程序输出结果为：1调用子类方法 7.类属性与方法类的私有属性private_attrs：两个下划线开头，声明该属性为私有，不能在类地外部被使用或直接访问。在类内部的方法中使用时 self.private_attrs。 类的方法在类地内部，使用def关键字可以为类定义一个方法，与一般函数定义不同，类方法必须包含参数self,且为第一个参数 类的私有方法private_method：两个下划线开头，声明该方法为私有方法，不能在类地外部调用。在类的内部调用 self.private_methods。 实例类的私有属性实例如下： 12345678910111213141516#!/usr/bin/python3class JustCounter: __secretCount = 0 # 私有变量 publicCount = 0 # 公开变量 def count(self): self.__secretCount += 1 self.publicCount += 1 print (self.__secretCount)counter = JustCounter()counter.count()counter.count()print (counter.publicCount)print (counter.__secretCount) # 报错，实例不能访问私有变量 类的私有方法实例如下： 12345678910111213141516171819202122#!/usr/bin/python3class Site: def __init__(self, name, url): self.name = name # public self.__url = url # private def who(self): print(&apos;name : &apos;, self.name) print(&apos;url : &apos;, self.__url) def __foo(self): # 私有方法 print(&apos;这是私有方法&apos;) def foo(self): # 公共方法 print(&apos;这是公共方法&apos;) self.__foo()x = Site(&apos;菜鸟教程&apos;, &apos;www.runoob.com&apos;)x.who() # 正常输出x.foo() # 正常输出x.__foo() # 报错 类的专有方法：1234567891011121314__init__ : 构造函数，在生成对象时调用__del__ : 析构函数，释放对象时使用__repr__ : 打印，转换__setitem__ : 按照索引赋值__getitem__: 按照索引获取值__len__: 获得长度__cmp__: 比较运算__call__: 函数调用__add__: 加运算__sub__: 减运算__mul__: 乘运算__div__: 除运算__mod__: 求余运算__pow__: 称方 运算符重载Python同样支持运算符重载，我么可以对类的专有方法进行重载，实例如下： 12345678910111213141516#!/usr/bin/python3class Vector: def __init__(self, a, b): self.a = a self.b = b def __str__(self): return &apos;Vector (%d, %d)&apos; % (self.a, self.b) def __add__(self,other): return Vector(self.a + other.a, self.b + other.b)v1 = Vector(2,10)v2 = Vector(5,-2)print (v1 + v2) 以上代码执行结果如下所示: 1Vector(7,8)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"面向对象","slug":"面向对象","permalink":"http://yoursite.com/tags/面向对象/"}]},{"title":"文件操作与数据存储json","slug":"文件操作与数据存储json","date":"2017-05-01T04:35:33.000Z","updated":"2018-01-23T05:25:23.581Z","comments":true,"path":"2017/05/01/文件操作与数据存储json/","link":"","permalink":"http://yoursite.com/2017/05/01/文件操作与数据存储json/","excerpt":"文件读取键盘读取Python2中有两个内置的函数可从标准输入读取数据，它默认来自键盘。这些函数分别是：input() 和 raw_input()。 但在Python3中，raw_input()函数已被弃用。此外， input() 函数是从键盘作为字符串读取数据，不论是否使用引号(‘’或“”)与否。","text":"文件读取键盘读取Python2中有两个内置的函数可从标准输入读取数据，它默认来自键盘。这些函数分别是：input() 和 raw_input()。 但在Python3中，raw_input()函数已被弃用。此外， input() 函数是从键盘作为字符串读取数据，不论是否使用引号(‘’或“”)与否。 12345678910#!/usr/bin/python3&gt;&gt;&gt; x=input(&quot;something:&quot;)something:10&gt;&gt;&gt; x&apos;10&apos;&gt;&gt;&gt; x=input(&quot;something:&quot;)something:&apos;10&apos; #entered data treated as string with or without &apos;&apos;&gt;&gt;&gt; x&quot;&apos;10&apos;&quot; 从本地读取打开和关闭文件open（）函数注意： 文件被打开后一定得记得关闭close（）。否则可能会损害文件。所以尽量使用 with 。让python自己判断什么时候该关闭，并自己去关闭。 open()后是一个对象，这个对象有read()方法与write()方法。 常用打开模式： 123456r 只能读 r+ 可读可写，不会创建不存在的文件，从顶部开始写，会覆盖之前此位置的内容w 只能写，覆盖整个原有文件（不要乱用），不存在则创建 w+ 可读可写，如果文件存在，则覆盖整个文件，不存在则创建a 只能写，从文件底部添加内容 不存在则创建 a+ 可读可写 从文件顶部读取内容 从文件底部添加内容 不存在则创建 如果我们在open文件后，没有进行任何读写，则默认r模式 123with open (&apos;pi.txt&apos;) as file_object : contents = file_object.read() print( contents ) 逐行读取： 1234filename = &apos;pi.txt&apos;with open (filename) as file_object : for line in file_object: print (line) 文件写入w模式：覆盖原有数据 1234filename = &apos;pi.txt&apos;with open (filename,&apos;w&apos;) as file_object : file_object.write(&quot;i love you \\n&quot;) file_object.write(&quot;i love you \\n&quot;) # 加上\\n可以一行一行的加入 a模式：添加新的内容，不会覆盖原有内容 1234filename = &apos;pi.txt&apos;with open (filename,&apos;a&apos;) as file_object : file_object.write(&quot;i love you \\n&quot;) file_object.write(&quot;i love you \\n&quot;) # 加上\\n可以一行一行的加入 数据存储jsonJSON (JavaScript Object Notation) 是一种轻量级的数据交换格式。它基于ECMAScript的一个子集。 Python3 中可以使用 json 模块来对 JSON 数据进行编解码，它包含了两个函数： 12json.dumps(): 对数据进行编码。json.loads(): 对数据进行解码。 在json的编解码过程中，python 的原始类型与json类型会相互转换，具体的转化对照如下： Python JSON dict object list, tuple array str string int, float, int- &amp; float-derived Enums number True true False false None null json.dumps 与 json.loads 实例以下实例演示了 Python 数据结构转换为JSON： 1234567891011121314#!/usr/bin/python3import json# Python 字典类型转换为 JSON 对象data = &#123; &apos;no&apos; : 1, &apos;name&apos; : &apos;Runoob&apos;, &apos;url&apos; : &apos;http://www.runoob.com&apos;&#125;json_str = json.dumps(data)print (&quot;Python 原始数据：&quot;, repr(data))print (&quot;JSON 对象：&quot;, json_str) 执行以上代码输出结果为： 12Python 原始数据： &#123;&apos;url&apos;: &apos;http://www.runoob.com&apos;, &apos;no&apos;: 1, &apos;name&apos;: &apos;Runoob&apos;&#125;JSON 对象： &#123;&quot;url&quot;: &quot;http://www.runoob.com&quot;, &quot;no&quot;: 1, &quot;name&quot;: &quot;Runoob&quot;&#125; 通过输出的结果可以看出，简单类型通过编码后跟其原始的repr()输出结果非常相似。接着以上实例，我们可以将一个JSON编码的字符串转换回一个Python数据结构： 12345678910111213141516171819#!/usr/bin/python3import json# Python 字典类型转换为 JSON 对象data1 = &#123; &apos;no&apos; : 1, &apos;name&apos; : &apos;Runoob&apos;, &apos;url&apos; : &apos;http://www.runoob.com&apos;&#125;json_str = json.dumps(data1)print (&quot;Python 原始数据：&quot;, repr(data1))print (&quot;JSON 对象：&quot;, json_str)# 将 JSON 对象转换为 Python 字典data2 = json.loads(json_str)print (&quot;data2[&apos;name&apos;]: &quot;, data2[&apos;name&apos;])print (&quot;data2[&apos;url&apos;]: &quot;, data2[&apos;url&apos;]) 执行以上代码输出结果为：1234Python 原始数据： &#123;&apos;name&apos;: &apos;Runoob&apos;, &apos;no&apos;: 1, &apos;url&apos;: &apos;http://www.runoob.com&apos;&#125;JSON 对象： &#123;&quot;name&quot;: &quot;Runoob&quot;, &quot;no&quot;: 1, &quot;url&quot;: &quot;http://www.runoob.com&quot;&#125;data2[&apos;name&apos;]: Runoobdata2[&apos;url&apos;]: http://www.runoob.com 如果你要处理的是文件而不是字符串，你可以使用 json.dump() 和 json.load() 来编码和解码JSON数据。例如： 1234567# 写入 JSON 数据with open(&apos;data.json&apos;, &apos;w&apos;) as f: json.dump(data, f)# 读取数据with open(&apos;data.json&apos;, &apos;r&apos;) as f: data = json.load(f)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"文件操作","slug":"文件操作","permalink":"http://yoursite.com/tags/文件操作/"}]},{"title":"python-慕课网-Python开发简单爬虫-蚂蚁-读书笔记","slug":"python-慕课网-Python开发简单爬虫-蚂蚁-读书笔记","date":"2017-04-27T13:07:04.000Z","updated":"2018-01-23T05:16:57.649Z","comments":true,"path":"2017/04/27/python-慕课网-Python开发简单爬虫-蚂蚁-读书笔记/","link":"","permalink":"http://yoursite.com/2017/04/27/python-慕课网-Python开发简单爬虫-蚂蚁-读书笔记/","excerpt":"本文阅读并记录自己的学习笔记。感谢蚂蚁大神的分享。 主要目录： 爬虫基础 1.1 爬虫课程介绍 1.2 爬虫简介 1.3 爬虫架构 1.4 URL管理模块 1.5 网页下载器：urllib2 1.6 网页解析器：正则或BeautifulSoup 1.7 爬取实践","text":"本文阅读并记录自己的学习笔记。感谢蚂蚁大神的分享。 主要目录： 爬虫基础 1.1 爬虫课程介绍 1.2 爬虫简介 1.3 爬虫架构 1.4 URL管理模块 1.5 网页下载器：urllib2 1.6 网页解析器：正则或BeautifulSoup 1.7 爬取实践 Scrapy框架的学习 2.1啊 爬虫的难点 有的网站需要登录 有些内容是JS的Ajax异步加载的。很难搞到数据。但是我们这门课是入门，所以只解决不需要登录的静态加载网页，上面2个问题以后专门去解决。 1 课程内容 爬虫简介 爬虫架构 URL管理器 网页下载器（urllib2） 网页解析器（BeautifulSoup） 实战 ：爬去百度百科关于Python的页面。保存进一个html页面中。 爬虫简介爬虫比人工快多了。 爬虫价值过程：爬虫：抓取数据-存储数据-分析数据-产品(大数据) 应用：","categories":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/categories/爬虫/"}],"tags":[{"name":"爬虫","slug":"爬虫","permalink":"http://yoursite.com/tags/爬虫/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python之if判断语句与while和for循环","slug":"Python之if判断语句与while和for循环","date":"2017-03-08T13:07:14.000Z","updated":"2018-01-23T05:17:20.129Z","comments":true,"path":"2017/03/08/Python之if判断语句与while和for循环/","link":"","permalink":"http://yoursite.com/2017/03/08/Python之if判断语句与while和for循环/","excerpt":"5-1 Python之if语句计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现： 12345age = 20if age &gt;= 18: print &apos;your age is&apos;, age print &apos;adult&apos;print &apos;END&apos;","text":"5-1 Python之if语句计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。 比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，可以用if语句实现： 12345age = 20if age &gt;= 18: print &apos;your age is&apos;, age print &apos;adult&apos;print &apos;END&apos; 注意: ==Python代码的缩进规则==。具有相同缩进的代码被视为代码块，上面的3，4行 print 语句就构成一个代码块（但不包括第5行的print）。如果 if 语句判断为 True，就会执行这个代码块。 缩进请严格按照Python的习惯写法：==4个空格==，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。 注意: if 语句后接表达式，然后用:表示代码块开始。 如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车： 1234567&gt;&gt;&gt; age = 20&gt;&gt;&gt; if age &gt;= 18:... print &apos;your age is&apos;, age... print &apos;adult&apos;...your age is 20adult 任务 如果成绩达到60分或以上，视为passed。 假设Bart同学的分数是75，请用if语句判断是否能打印出 passed: 答案： 123score = 75if score &gt;= 60: print &apos;passed&apos; 5-2 Python之 if-else当 if 语句判断表达式的结果为 True 时，就会执行 if 包含的代码块： 12if age &gt;= 18: print &apos;adult&apos; 如果我们想判断年龄在18岁以下时，打印出 ‘teenager’，怎么办？ 方法是再写一个 if: 12if age &lt; 18: print &apos;teenager&apos; 或者用 not 运算： 12if not age &gt;= 18: print &apos;teenager&apos; 细心的同学可以发现，这两种条件判断是“非此即彼”的，要么符合条件1，要么符合条件2，因此，完全可以用一个 if … else … 语句把它们统一起来： 1234if age &gt;= 18: print &apos;adult&apos;else: print &apos;teenager&apos; 利用 if … else … 语句，我们可以根据条件表达式的值为 True 或者 False ，分别执行 if 代码块或者 else 代码块。 注意: else 后面有个“:”。 任务 如果成绩达到60分或以上，视为passed，否则视为failed。 假设Bart同学的分数是55，请用if语句打印出 passed 或者 failed: 答案 12345score = 55if score &gt;= 60: print &apos;passed&apos;else: print &apos;failed&apos; #5-3 Python之 if-elif-else 有的时候，一个 if … else … 还不够用。比如，根据年龄的划分： 123条件1：18岁或以上：adult条件2：6岁或以上：teenager条件3：6岁以下：kid 我们可以用一个 if age &gt;= 18 判断是否符合条件1，如果不符合，再通过一个 if 判断 age &gt;= 6 来判断是否符合条件2，否则，执行条件3： 1234567if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: print &apos;kid&apos; 这样写出来，我们就得到了一个两层嵌套的 if … else … 语句。这个逻辑没有问题，但是，如果继续增加条件，比如3岁以下是 baby： 12345678910if age &gt;= 18: print &apos;adult&apos;else: if age &gt;= 6: print &apos;teenager&apos; else: if age &gt;= 3: print &apos;kid&apos; else: print &apos;baby&apos; 这种缩进只会越来越多，代码也会越来越难看。 要避免嵌套结构的 if … else …，我们可以用 if … 多个elif … else … 的结构，一次写完所有的规则： 12345678if age &gt;= 18: print &apos;adult&apos;elif age &gt;= 6: print &apos;teenager&apos;elif age &gt;= 3: print &apos;kid&apos;else: print &apos;baby&apos; elif 意思就是 else if。这样一来，我们就写出了结构非常清晰的一系列条件判断。 特别注意: 这一系列条件判断会从上到下依次判断，如果某个判断为 True，执行完对应的代码块，后面的条件判断就直接忽略，不再执行了。 请思考下面的代码： 1234567age = 8if age &gt;= 6: print &apos;teenager&apos;elif age &gt;= 18: print &apos;adult&apos;else: print &apos;kid&apos; 当 age = 8 时，结果正确，但 age = 20 时，为什么没有打印出 adult？ 如果要修复，应该如何修复？ 任务 如果按照分数划定结果： 90分或以上：excellent 80分或以上：good 60分或以上：passed 60分以下：failed 请编写程序根据分数打印结果。 答案 12345678910score = 85if score &gt;= 90: print &apos;excellent&apos;elif score &gt;= 80: print &apos;good&apos;elif score &gt;= 60: print &apos;passed&apos;else : print &apos;failed&apos; #5-4 Python之 for循环 list或tuple可以表示一个有序集合。如果我们想依次访问一个list中的每一个元素呢？比如 list： 1234L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]print L[0]print L[1]print L[2] 如果list只包含几个元素，这样写还行，如果list包含1万个元素，我们就不可能写1万行print。 这时，循环就派上用场了。 Python的 for 循环就可以依次把list或tuple的每个元素迭代出来： 123L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]for name in L: print name 注意: name 这个变量是在 for 循环中定义的，意思是，依次取出list中的每一个元素，并把元素赋值给 name，然后执行for循环体（就是缩进的代码块）。 这样一来，遍历一个list或tuple就非常容易了。 任务 班里考试后，老师要统计平均成绩，已知4位同学的成绩用list表示如下： L = [75, 92, 59, 68] 请利用for循环计算出平均成绩。 答案 12345L = [75, 92, 59, 68]sum = 0.0for x in L: sum += xprint sum / 4 #5-5 Python之 while循环 Python之 while循环 和 for 循环不同的另一种循环是 while 循环，while 循环不会迭代 list 或 tuple 的元素，而是根据表达式判断循环是否结束。 比如要从 0 开始打印不大于 N 的整数： 12345N = 10x = 0while x &lt; N: print x x = x + 1 while循环每次先判断 x &lt; N，如果为True，则执行循环体的代码块，否则，退出循环。 在循环体内，x = x + 1 会让 x 不断增加，最终因为 x &lt; N 不成立而退出循环。 如果没有这一个语句，while循环在判断 x &lt; N 时总是为True，就会无限循环下去，变成死循环，所以要特别留意while循环的退出条件。 任务 利用while循环计算100以内奇数的和。 答案 123456sum = 0x = 1while x &lt;100: sum += x x += 2print sum #5-6 Python之 break退出循环 Python之 break退出循环 用 for 循环或者 while 循环时，如果要在循环体内直接退出循环，可以使用 break 语句。 比如计算1至100的整数和，我们用while来实现： 12345678sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum 咋一看， while True 就是一个死循环，但是在循环体内，我们还判断了 x &gt; 100 条件成立时，用break语句退出循环，这样也可以实现循环的结束。 任务 利用 while True 无限循环配合 break 语句，计算 1 + 2 + 4 + 8 + 16 + … 的前20项的和。 答案： 12345678910sum = 0x = 1n = 1while True: sum += x x = x * 2 n += 1 if n &gt; 20: breakprint sum #5-7 Python之 continue继续循环 Python之 continue继续循环 在循环过程中，可以用break退出当前循环，还可以用continue跳过后续循环代码，继续下一次循环。 假设我们已经写好了利用for循环计算平均分的代码： 1234567L = [75, 98, 59, 81, 66, 43, 69, 85]sum = 0.0n = 0for x in L: sum = sum + x n = n + 1print sum / n 现在老师只想统计及格分数的平均分，就要把 x &lt; 60 的分数剔除掉，这时，利用 continue，可以做到当 x &lt; 60的时候，不继续执行循环体的后续代码，直接进入下一次循环： 12345for x in L: if x &lt; 60: continue sum = sum + x n = n + 1 任务 对已有的计算 0 - 100 的while循环进行改造，通过增加 continue 语句，使得只计算奇数的和： 12345678sum = 0x = 1while True: sum = sum + x x = x + 1 if x &gt; 100: breakprint sum 答案 12345678910sum = 0x = 0while True: x = x + 1 if x &gt; 100: break if x % 2 == 0: continue sum += xprint sum #5-8 Python之 多重循环 Python之 多重循环 在循环内部，还可以嵌套循环，我们来看一个例子： 123for x in [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]: for y in [&apos;1&apos;, &apos;2&apos;, &apos;3&apos;]: print x + y x 每循环一次，y 就会循环 3 次，这样，我们可以打印出一个全排列： 123456789A1A2A3B1B2B3C1C2C3 任务 对100以内的两位数，请使用一个两重循环打印出所有十位数数字比个位数数字小的数，例如，23（2 &lt; 3）。 答案1234for x in [1,2,3,4,5,6,7,8,9]: for y in [0,1,2,3,4,5,6,7,8,9]: if x &lt; y: print(10 * x + y)","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python中的列表list","slug":"Python中的列表list","date":"2017-03-08T13:02:04.000Z","updated":"2018-01-23T05:17:26.597Z","comments":true,"path":"2017/03/08/Python中的列表list/","link":"","permalink":"http://yoursite.com/2017/03/08/Python中的列表list/","excerpt":"4-1 Python创建listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： 12&gt;&gt;&gt; [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;][&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]","text":"4-1 Python创建listPython内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。 比如，列出班里所有同学的名字，就可以用一个list表示： 12&gt;&gt;&gt; [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;][&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] list是数学意义上的有序集合，也就是说，list中的元素是按照顺序排列的。 构造list非常简单，按照上面的代码，直接用 [ ] 把list的所有元素都括起来，就是一个list对象。 通常，我们会把list赋值给一个变量，这样，就可以通过变量来引用list： 123&gt;&gt;&gt; classmates = [&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;]&gt;&gt;&gt; classmates # 打印classmates变量的内容[&apos;Michael&apos;, &apos;Bob&apos;, &apos;Tracy&apos;] 由于Python是动态语言，所以list中包含的元素并不要求都必须是同一种数据类型，我们完全可以在list中包含各种数据： 1&gt;&gt;&gt; L = [&apos;Michael&apos;, 100, True] 一个元素也没有的list，就是空list： 1&gt;&gt;&gt; empty_list = [] 任务 假设班里有3名同学：Adam，Lisa和Bart，他们的成绩分别是 95.5，85 和 59，请按照 名字, 分数, 名字, 分数… 的顺序按照分数从高到低用一个list表示，然后打印出来。 解答： 12L = [&apos;adam&apos;,95.5,&apos;lisa&apos;,85,&apos;bart&apos;,59]print L 4-2 Python按照索引访问list由于list是一个有序集合，所以，我们可以用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart'] 那我们如何从list中获取指定第 N 名的同学呢？方法是通过索引来获取list中的指定元素。 需要特别注意的是，索引从 0 开始，也就是说，第一个元素的索引是0，第二个元素的索引是1，以此类推。 因此，要打印第一名同学的名字，用 L[0]: 12&gt;&gt;&gt; print L[0]Adam 要打印第二名同学的名字，用 L[1]: 12&gt;&gt;&gt; print L[1]Lisa 要打印第三名同学的名字，用 L[2]: 12&gt;&gt;&gt; print L[2]Bart 要打印第四名同学的名字，用 L[3]: 1234&gt;&gt;&gt; print L[3]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range 报错了！IndexError意思就是索引超出了范围，因为上面的list只有3个元素，有效的索引是 0，1，2。 所以，使用索引时，千万注意不要越界。 任务 三名同学的成绩可以用一个list表示： L = [95.5, 85, 59] 请按照索引分别打印出第一名、第二名、第三名、第四名的分数。 答案 12345L = [95.5,85,59]print (L[0])print (L[1])print (L[2])print (L[-1]) 4-3 Python之倒序访问list我们还是用一个list按分数从高到低表示出班里的3个同学： 1&gt;&gt;&gt; L = ['Adam', 'Lisa', 'Bart'] 这时，老师说，请分数最低的同学站出来。 要写代码完成这个任务，我们可以先数一数这个 list，发现它包含3个元素，因此，最后一个元素的索引是2： 12&gt;&gt;&gt; print L[2]Bart 有没有更简单的方法？ 有！ Bart同学是最后一名，俗称倒数第一，所以，我们可以用 -1 这个索引来表示最后一个元素： 12&gt;&gt;&gt; print L[-1]Bart Bart同学表示躺枪。 类似的，倒数第二用 -2 表示，倒数第三用 -3 表示，倒数第四用 -4 表示： 12345678&gt;&gt;&gt; print L[-2]Lisa&gt;&gt;&gt; print L[-3]Adam&gt;&gt;&gt; print L[-4]Traceback (most recent call last): File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range L[-4] 报错了，因为倒数第四不存在，一共只有3个元素。 使用倒序索引时，也要注意不要越界。 任务 三名同学的成绩可以用一个list表示： L = [95.5, 85, 59] 请按照倒序索引分别打印出倒数第一、倒数第二、倒数第三。 答案： 1234L = [95.5, 85, 59]print (L[-1])print (L[-2])print (L[-3]) 4-4 Python之添加新元素12append() 方法insert()方法 现在，班里有3名同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 今天，班里转来一名新同学 Paul，如何把新同学添加到现有的 list 中呢？ 第一个办法是用 list 的 append() 方法，把新同学追加到 list 的末尾： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.append(&apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;] append()总是把新的元素添加到 list 的尾部。 如果 Paul 同学表示自己总是考满分，要求添加到第一的位置，怎么办？ 方法是用list的 insert()方法，它接受两个参数，第一个参数是索引号，第二个参数是待添加的新元素： 1234&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]&gt;&gt;&gt; L.insert(0, &apos;Paul&apos;)&gt;&gt;&gt; print L[&apos;Paul&apos;, &apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] L.insert(0, ‘Paul’) 的意思是，’Paul’将被添加到索引为 0 的位置上（也就是第一个），而原来索引为 0 的Adam同学，以及后面的所有同学，都自动向后移动一位。 任务 假设新来一名学生Paul，Paul 同学的成绩比Bart好，但是比Lisa差，他应该排到第三名的位置，请用代码实现。 解 123L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]L.insert(2,&apos;Paul&apos;)print L 4-5 Python从list删除元素Paul同学刚来几天又要转走了，那么我们怎么把Paul 从现有的list中删除呢？ 如果Paul同学排在最后一个，我们可以用list的pop()方法删除： 12345&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Paul&apos;]&gt;&gt;&gt; L.pop()&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] pop()方法总是删掉list的最后一个元素，并且它还返回这个元素，所以我们执行 L.pop() 后，会打印出 ‘Paul’。 如果Paul同学不是排在最后一个怎么办？比如Paul同学排在第三： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;] 要把Paul踢出list，我们就必须先定位Paul的位置。由于Paul的索引是2，因此，用 pop(2)把Paul删掉： 1234&gt;&gt;&gt; L.pop(2)&apos;Paul&apos;&gt;&gt;&gt; print L[&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 任务 注意右边编辑器代码中 list 如下： L = [‘Adam’, ‘Lisa’, ‘Paul’, ‘Bart’] Paul的索引是2，Bart的索引是3，如果我们要把Paul和Bart都删掉，请解释下面的代码为什么不能正确运行： L.pop(2) L.pop(3) 怎样调整代码可以把Paul和Bart都正确删除掉？ 答： 1234L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;, &apos;Bart&apos;]L.pop(3)L.pop(2)print L 4-6 Python中替换元素list是可变的。 假设现在班里仍然是3名同学： 1&gt;&gt;&gt; L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;] 现在，Bart同学要转学走了，碰巧来了一个Paul同学，要更新班级成员名单，我们可以先把Bart删掉，再把Paul添加进来。 另一个办法是直接用Paul把Bart给替换掉： 123&gt;&gt;&gt; L[2] = &apos;Paul&apos;&gt;&gt;&gt; print LL = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Paul&apos;] 对list中的某一个索引赋值，就可以直接用新的元素替换掉原来的元素，list包含的元素个数保持不变。 由于Bart还可以用 -1 做索引，因此，下面的代码也可以完成同样的替换工作： 1&gt;&gt;&gt; L[-1] = &apos;Paul&apos; 任务 班里的同学按照分数排名是这样的： L = [‘Adam’, ‘Lisa’, ‘Bart’] 但是，在一次考试后，Bart同学意外取得第一，而Adam同学考了倒数第一。 请通过对list的索引赋值，生成新的排名。 答案 1234L = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;]L.append(L.pop(0)) L.insert(0,L.pop(1))print L","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"list tuple dict set的对比","slug":"list tuple dict set的对比","date":"2017-03-08T04:35:33.000Z","updated":"2018-01-23T04:42:31.264Z","comments":true,"path":"2017/03/08/list tuple dict set的对比/","link":"","permalink":"http://yoursite.com/2017/03/08/list tuple dict set的对比/","excerpt":"[toc] 基本用法定义:list:链表,有序的项目, 通过索引进行查找,使用方括号”[]”;tuple:元组,元组将多样的对象集合到一起,不能修改,通过索引进行查找, 使用括号”()”;dict:字典,字典是一组键(key)和值(value)的组合,通过键(key)进行查找,没有顺序, 使用大括号”{}”;set:集合,无序,元素只出现一次, 自动去重,使用”set([])”应用场景:list, 简单的数据集合,可以使用索引;tuple, 把一些数据当做一个整体去使用,不能修改;dict,使用键值和值进行关联的数据;set,数据只出现一次,只关心数据是否出现, 不关心其位置;","text":"[toc] 基本用法定义:list:链表,有序的项目, 通过索引进行查找,使用方括号”[]”;tuple:元组,元组将多样的对象集合到一起,不能修改,通过索引进行查找, 使用括号”()”;dict:字典,字典是一组键(key)和值(value)的组合,通过键(key)进行查找,没有顺序, 使用大括号”{}”;set:集合,无序,元素只出现一次, 自动去重,使用”set([])”应用场景:list, 简单的数据集合,可以使用索引;tuple, 把一些数据当做一个整体去使用,不能修改;dict,使用键值和值进行关联的数据;set,数据只出现一次,只关心数据是否出现, 不关心其位置; List 列表创建List：L = [‘Adam’, ‘Lisa’, ‘Bart’, ‘Gechong’, ‘Kongming’] 显示List：L[0] 遍历List：print (L)和for循环 更新List：append()和insert()和直接赋值 删除List：pop()和pop(n) List特点： 可以添加删除 123456Li = [&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Gechong&apos;, &apos;Kongming&apos;] print (Li) for name in Li: print(name) Tuple 元组创建Tuple：Tu = (‘Adam’, ‘Lisa’, ‘Bart’, ‘Gechong’, ‘Kongming’) 显示Tuple：Tu[0] 遍历Tuple：print (Tu)和for循环 更新Tuple：不可以更新 删除Tuple：不可以删除 Tuple特点：不可以改变，如果创建之后一个元素的Tuple时，要加”,” 123456Tu = (&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Gechong&apos;, &apos;Kongming&apos;) print (Tu) for name in Tu: print(name) Dict字典创建Dict：Di = {‘Adam’:100, ‘Lisa’:90, ‘Bart’:93, ‘Gechong’:100, ‘Kongming’:100} 显示Dict：Di[‘Adam’]和Di.get(‘Adam’) 遍历Dict：print(Di)和for循环 1234Di = &#123;&apos;Adam&apos;:100, &apos;Lisa&apos;:90, &apos;Bart&apos;:93, &apos;Gechong&apos;:100, &apos;Kongming&apos;:100&#125; for key in Di: print (key) 1234Di = &#123;&apos;Adam&apos;:100, &apos;Lisa&apos;:90, &apos;Bart&apos;:93, &apos;Gechong&apos;:100, &apos;Kongming&apos;:100&#125; for key in Di: print (Di[key]) 更新Dict：对应位置赋值即可 删除Dict： Dict特点： 1：查找速度快 2：浪费空间 3：key不可以重复，且不可变 4：数据无序排放 set 集合创建set：s = set([‘Adam’, ‘Lisa’, ‘Bart’, ‘Gechong’, ‘Kongming’]) 显示set： 123456s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Gechong&apos;, &apos;Kongming&apos;]) if &apos;Test&apos; in s: print (&apos;Test&apos;)else: print (&apos;No&apos;) 遍历set：print (s) 1234s = set([&apos;Adam&apos;, &apos;Lisa&apos;, &apos;Bart&apos;, &apos;Gechong&apos;, &apos;Kongming&apos;]) for name in s: print (name) 更新set：s.add() 删除set：s.remove() 考虑性能Python中Set和List的性能差距能有数百倍如果有需要求（集合，列表等）的并集和交集的时候，最好使用Set。 set和lsit可以自由转换，在删除list中多个/海量重复元素时，可以先转换成set，然后再转回list并排序(set没有排序)。此种方法不仅方便且效率较高。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}]},{"title":"Python深度学习路线","slug":"Python深度学习路线","date":"2017-03-05T13:07:04.000Z","updated":"2018-01-23T03:22:05.104Z","comments":true,"path":"2017/03/05/Python深度学习路线/","link":"","permalink":"http://yoursite.com/2017/03/05/Python深度学习路线/","excerpt":"[TOC] 学习对象所有==大四==以及==研一==学生，研二感兴趣的学生也可参加 深度学习准备篇==Python基础语法==","text":"[TOC] 学习对象所有==大四==以及==研一==学生，研二感兴趣的学生也可参加 深度学习准备篇==Python基础语法== 自学，资料非常多，推荐http://www.runoob.com/python3/python3-tutorial.html。 学习时间：3天-7天 框架安装：Anaconda 掌握程度，基础语法掌握，对于面向对象语法不必掌握==Python库====Python库-numpy==自学，资料非常多，建议看博客即可。 学习时间：1天 掌握程度：numpy对数组对象的封装，理解其思想与原理 学习链接：https://docs.scipy.org/doc/numpy-dev/user/quickstart.html==Python库-pandas==自学，资料非常多，建议看书或博客。 学习时间：1天 掌握程度：知道大概，会使用即可，比如DataFrame 学习链接：http://pandas.pydata.org/pandas-docs/stable/10min.html==Python库-matplotlib==自学，不建议太深入。 学习时间：半天 掌握程度：能够对官网的例子进行修改使用即可 学习链接：http://matplotlib.org/gallery.html深度学习库-TensorFlow本部分会进行一个入门讲解，其它API需要自己去看，去实践。深度学习库-Keras本部分会进行一个入门讲解，其它API需要自己去看，去实践深度学习实战篇CNN网络讲解原理，大家自己动手去实践应用场景卷积层降采样层激励函数文本分类实践RNN/LSTM网络实践讲解原理，大家自己动手去实践应用场景RNN记忆单元LSTM记忆单元文本生成/预测实践","categories":[{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/categories/深度学习/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"深度学习","slug":"深度学习","permalink":"http://yoursite.com/tags/深度学习/"},{"name":"CNN","slug":"CNN","permalink":"http://yoursite.com/tags/CNN/"},{"name":"RNN","slug":"RNN","permalink":"http://yoursite.com/tags/RNN/"}]},{"title":"utf-8项目生成javadoc时:报错:编码GB:的不可映射字符","slug":"utf-8项目生成javadoc时:报错:编码GB:的不可映射字符","date":"2017-02-19T13:07:04.000Z","updated":"2018-01-23T03:29:31.700Z","comments":true,"path":"2017/02/19/utf-8项目生成javadoc时:报错:编码GB:的不可映射字符/","link":"","permalink":"http://yoursite.com/2017/02/19/utf-8项目生成javadoc时:报错:编码GB:的不可映射字符/","excerpt":"utf-8项目生成javadoc时，报错： 编码GBK 的不可映射字符这是因为：由于JDK是国际版的，在编译的时候，如果我们没有用-encoding参数指定我们的Java源程序的编码格式，则javac.exe首先获得我们操作系统默认采用的编码格式， 也即在编译java程序时，若我们不指定源程序文件的编码格式，JDK首先获得操作系统的file.encoding参数(它保存的就是操作系统默认的编码格式，如WIN2k，它的值为GBK)， 然后JDK就把我们的java源程序从file.encoding编码格式转化为JAVA内部默认的UNICODE格式放入内存中。","text":"utf-8项目生成javadoc时，报错： 编码GBK 的不可映射字符这是因为：由于JDK是国际版的，在编译的时候，如果我们没有用-encoding参数指定我们的Java源程序的编码格式，则javac.exe首先获得我们操作系统默认采用的编码格式， 也即在编译java程序时，若我们不指定源程序文件的编码格式，JDK首先获得操作系统的file.encoding参数(它保存的就是操作系统默认的编码格式，如WIN2k，它的值为GBK)， 然后JDK就把我们的java源程序从file.encoding编码格式转化为JAVA内部默认的UNICODE格式放入内存中。然后，javac把转换后的unicode格式的文件进行编译成.class类文件， 此时.class文件是UNICODE编码的，它暂放在内存中，紧接着，JDK将此以UNICODE编码的编译后的class文件保存到我们的操作系统中形成我们见到的.class文件。 对我们来说，我们最终获得的.class文件是内容以UNICODE编码格式保存的类文件，它内部包含我们源程序中的中文字符串，只不过此时它己经由file.encoding格式转化为UNICODE格式了。 当我们不加设置就编译时，相当于使用了参数：javac -encoding gbk XX.java，当然就会出现不兼容的情况。 解决办法：打开eclipse，右键点击project -&gt; Generate javadoc 一项一项的选你要输出javadoc的项目，最后一步中VM设置行中加入以下代码：1-encoding utf-8 -charset utf-8","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"UTF-8","slug":"UTF-8","permalink":"http://yoursite.com/tags/UTF-8/"},{"name":"GBK","slug":"GBK","permalink":"http://yoursite.com/tags/GBK/"},{"name":"编码","slug":"编码","permalink":"http://yoursite.com/tags/编码/"}]},{"title":"Python学习路线","slug":"Python学习路线","date":"2016-12-20T13:07:04.000Z","updated":"2018-01-23T03:16:18.196Z","comments":true,"path":"2016/12/20/Python学习路线/","link":"","permalink":"http://yoursite.com/2016/12/20/Python学习路线/","excerpt":"谈到学习路线，入门是基础课。基本上，熟练掌握Python入门指南即可。 其次，要想更进一步，需要熟读官方文档，掌握各种内置函数、标准库等知识。关于两者，英文不好的鱼油们可以关Python中文官方文档板块，也欢迎有余力的鱼油加入我们的团队。关于Python的奇淫技巧，可以看《Effective Python：编写高质量Python代码的59个有效方法》这本书。","text":"谈到学习路线，入门是基础课。基本上，熟练掌握Python入门指南即可。 其次，要想更进一步，需要熟读官方文档，掌握各种内置函数、标准库等知识。关于两者，英文不好的鱼油们可以关Python中文官方文档板块，也欢迎有余力的鱼油加入我们的团队。关于Python的奇淫技巧，可以看《Effective Python：编写高质量Python代码的59个有效方法》这本书。 再次，在进一步发展之前，强烈建议先get几个附加技能，以避免以后可能遇到的不必要的大坑。 Linux 开发利器。有兴趣的鱼油可以安装Linux系统后，移步Linux入门教程。 Vim 编程利器。有兴趣的鱼油可以移步小甲鱼的VIM魔鬼训练营。 Git 全世界最大的开源代码托管平台。有兴趣的鱼油可以移步Git实用教程。 English 基础技能，无需多言。 方向最后，谈到发展方向，就楼主所知的有以下几个方向。 Web开发 如Flask、Django、Tornado等等，需要良好的文档阅读能力。推荐书籍： 《FlaskWeb开发：基于Python的Web应用开发实战》、《The Django Book》等。 渗透测试 陡峭的学习曲线，需要其它如汇编、计算机网络、数据结构等基础知识。推荐书籍：《Python灰帽子》、《Python黑帽子》等。 数据挖掘/大数据 据说还需要学习其它语言，如R语言等。推荐从Scrapy入手。这里有张图，我认为规划的最好： 科学计算 了解不多~_~ … 推荐书籍：《Python科学计算》。 机器学习 了解不多~_~ … 推荐书籍：《机器学习实战》。 软件开发 如Tkinter、wxpython、PyQt、PyGTK+等等。这些图形界面库各有优缺点。其中PyQt普及程度要搞一些，比如说有道词典Linux版、深度截图用的就是PyQt5。有兴趣的鱼油可以移步淘贴PyQt。 软件测试测试 如Selenium、QTP等自动化测试工具。有兴趣的鱼油可以移步自动化测试框架Selenium。推荐书籍：《Selenium 2自动化测试实战——基于Python语言》。","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"学习路线","slug":"学习路线","permalink":"http://yoursite.com/tags/学习路线/"}]},{"title":"VC6.0+ddk+DriverStudio3.2安装与配置","slug":"VC6.0+ddk+DriverStudio3.2安装与配置","date":"2016-11-18T13:07:04.000Z","updated":"2018-01-23T03:12:11.564Z","comments":true,"path":"2016/11/18/VC6.0+ddk+DriverStudio3.2安装与配置/","link":"","permalink":"http://yoursite.com/2016/11/18/VC6.0+ddk+DriverStudio3.2安装与配置/","excerpt":"再学习VS2013+wdk之前。首先学习VC6.0+ddk+DriverStudio3.2环境下的驱动开发，来理解驱动的世界。完全新手，从零开始，亚历山大，且行且珍惜。。。。。 首先是：环境的搭建","text":"再学习VS2013+wdk之前。首先学习VC6.0+ddk+DriverStudio3.2环境下的驱动开发，来理解驱动的世界。完全新手，从零开始，亚历山大，且行且珍惜。。。。。 首先是：环境的搭建 安装和配置一.软件的安装顺序:Windows XP（虚拟机中） –&gt; VC6.0 –&gt; WinXP_DDK -&gt; DriverStudio3.2，如果顺序装错了，那么把DriverStudio3.2删除再重装就OK了。 下载地址：1.vc6.0英文原版（最好不要用中文版）: http://down.liangchan.net/microsoftvisualc-en6.0.zip 2.WinXP_DDK：安装DDK，安装时注意需要将所有的组件、工具、例子等都安装（避免出现hidport.h找不到的问题）。 http://download.microsoft.com/download/9/0/f/90f019ac-8243-48d3-91cf-81fc4093ecfd/1830_usa_ddk.iso 3.DriverStudio3.2： http://ttl4.pc6.com/tx/driverstudio.zip （安装时会检测系统有无D盘，如果虚机中XP无D盘，安装不上。用“分区助手”分下区即可） 二.配置DriverStudio1.从网上找到库文件 ntstrsafe.lib+csq.lib.rar，把解压出来的两个库文件拷贝到WinXP_DDK的安装目录下的库目录中.（我的是 C:\\WINDDK\\2600\\lib\\wxp\\i386）。启动vc6，然后进行简单的配置：菜单DriverStudio菜单下的DDK Build Settings，在弹出的对话框中选择已经安装的DDK目录（比如我的是C:\\WINDDK\\2600）， （ntstrsafe.lib+csq.lib.rar下载地址： http://download.csdn.net/detail/victoryckl/4444640 ） 2.在Windows DDK compiler Options中选择”Enable only for Driver Studio”。VC6.0–&gt;Tools–&gt;Options，点击”Directories”选项卡：1）·“Show directories for:”下选择Include files，然后检查有没有包含ddk的头文件目录（我的是C:\\WINDDK\\2600\\inc\\wxp），如果没有则加上； 以及123C:\\WINDDK\\2600\\INC\\W2K C:\\WINDDK\\2600\\INC\\DDK\\W2K C:\\WINDDK\\2600\\INC\\DDK\\WDM\\W2K 2）·“Show directories for:”下选择Library files，然后检查有没有包含ddk的库文件目录（我的是C:\\WINDDK\\2600\\lib\\wxp\\i386），如果没有则加上；以及 C:\\WINDDK\\2600\\LIB\\W2K\\I386 三。编译库文件（一定注意32位）·编译适合本机使用的库文件（以下内容，如果用DDK编程者可以不看） (1).启动VC6.0。开始–&gt;所有程序 –&gt;Compuware DriveStudio–&gt;Develop–&gt;DDK Building Settings，确保“DDK Root Directory”下方的内容是ddk的安装目录（比如我的是C:\\WINDDK\\2600），然后点击下方的”Luanch Program”正式启动vc6的开发环境。 (2).进入菜单File–&gt;Open Workspace(打开位于DriverStudio3.2安装目录的\\DriverWorks\\Source\\vdwlibs.dsw)–&gt; 进入菜单Build–&gt;batch Build，点击“Select x86”按钮只选中全部的32位库（我的电脑是32位的。注意：对于32位的电脑一定不要选中64位的库，否则后面编译会出错）–&gt;点击按 钮”Rebuild AlL”开始编译。(注意：这种方法我曾经成功过一次，但后来再也没成功过，于是百度GOOGLE很久，发现下面这样也行：设置VdwLibs为活动项，选中Win32 WDM Checked,然后用DriverStudio里面的 Build with Build.exe即可以。然后再选Win32 WDM Free再Build一下，这样就出现了想要的vdw_wdm.lib） 注:如果出现无法打开文件这类的错误,一般都是DDK Build Settings指向不对，或安装顺序有误，或者你在３２位机器上选中了６４位库。 四·编译一个DriverStudio自带的实例（１）·启动ｖｃ６，点击菜单 File–&gt;Open Workspace，打开项目文件C:\\Program Files\\Compuware\\DriverStudio\\DriverWorks\\Examples\\wdm\\hellowdm \\HelloWdm.dsw，然后编译，如果没有报错，那说明安装和配置成功。但请你别高兴的太早，开发环境安装配置成功只是万里长城的第一步，剩下的你 就是要理解驱动模块的架构和具体的代码编写了。 五·使用Driver wizard生成驱动程序框架(1).在VC6.0的界面下,点击菜单DriverStudio–&gt;Driver wizard，此后系统会一步一步引导你完成设置，最后自动生产的驱动程序框架。 (2).设置好后将生成驱动文件,然后用VC6.0进行编译：进行Build菜单,Rebuild AlL将生成.sys文件,说明驱动模块编译成功！ 注:如果出现无法打开ntstrsafe.lib的错误，说明系统缺少这个库文件，参照上面的方法补上这个库文件，或者进入菜单 Project–&gt;Settings，鼠标点击左边方框里的最上面一行，然后右边”Project Option”下的ntstrsafe.lib并删除它。","categories":[{"name":"驱动开发","slug":"驱动开发","permalink":"http://yoursite.com/categories/驱动开发/"}],"tags":[{"name":"USB","slug":"USB","permalink":"http://yoursite.com/tags/USB/"},{"name":"驱动程序","slug":"驱动程序","permalink":"http://yoursite.com/tags/驱动程序/"},{"name":"DriverSttudio3.2","slug":"DriverSttudio3-2","permalink":"http://yoursite.com/tags/DriverSttudio3-2/"},{"name":"ddk","slug":"ddk","permalink":"http://yoursite.com/tags/ddk/"}]},{"title":"运维团队(OPS)与技术团队有效沟通配合探讨","slug":"运维团队(OPS)与技术团队有效沟通配合探讨","date":"2016-09-20T13:07:04.000Z","updated":"2018-01-23T03:08:28.732Z","comments":true,"path":"2016/09/20/运维团队(OPS)与技术团队有效沟通配合探讨/","link":"","permalink":"http://yoursite.com/2016/09/20/运维团队(OPS)与技术团队有效沟通配合探讨/","excerpt":"一、技术团队细分及配合问题在IT企业里产品从创意到交付给用户，从整体上看是由技术部门负责，但如果深入到技术部门，会发现由不同的技术团队负责不同的部分或者阶段。一般会分产品团队、开发团队、测试团队以及运维团队，在互联网公司里，运维团队一般还分基础运维和产品运维两个团队，基础运维负责基础设施(包括机架、网络、硬件)和操作系统的安装，为整体公司的所有产品提供基础设施的运维服务。而产品运维负责线上产品的问题处理、代码的布署和跟开发的接口等。","text":"一、技术团队细分及配合问题在IT企业里产品从创意到交付给用户，从整体上看是由技术部门负责，但如果深入到技术部门，会发现由不同的技术团队负责不同的部分或者阶段。一般会分产品团队、开发团队、测试团队以及运维团队，在互联网公司里，运维团队一般还分基础运维和产品运维两个团队，基础运维负责基础设施(包括机架、网络、硬件)和操作系统的安装，为整体公司的所有产品提供基础设施的运维服务。而产品运维负责线上产品的问题处理、代码的布署和跟开发的接口等。 不同的技术团队一般隶属不同的部门，分散在公司不同的办公区域，团队内部的沟通相对多一些，但团队之间的沟通较少。不同团队都会形成自己的办事习惯、节奏，都有自己的关注点，一般只是知道与之接口的团队的总体职责，但是不知道对方可能面临的困难与工作中的挑战点。另外，如果公司够大，每个团队内部又会分为许更细的小团队，如基础运维一般有系统团队、网络团队和IDC团队等，这样更加重了团队之间沟通难度。 从产品策划到上线，一般是以下边的顺序经过各个团队： 开发团队收集产品的需求，定下时间表并进行开发 开发完后，交由测试或质量团队进行测试 然后交给运维团队布署新产品或新版本 运维团队将运维过程中发现的代码缺陷反馈给开发团队进行修复 在上面的每个阶段，对应的团队都是各做各的，一般是在最后才会把球踢给下一个团队，如果下一个团队发现问题又会把球踢回原来的团队。如果你深入到不同的团队中去，或听到不同的抱怨声音。 基础运维团队经常抱怨： 产品开发一点计划都没有，突然要上线机器，让我们措手不及。每个产品都急着上线，谁催得急就上谁的，谁能说一下，到底那个重要？动不动就要重装系统，坏了一块盘就着急去修，刚从机房回来，又要过去。上线太突然了，没有交换机，没有机架，还需要搬别的机器腾地方。那个地方有机架和交换机端口，但没有四层设备，他们又要放在四层后边，真的没有办法了。刚跟他们上线到一个机房，他们又说要换到另一个机房，尽折腾。他们怎么能那么用设备，把上连端口带宽都跑满了。 产品运维团队会说： 真没办法，上个线不是说没机架，就是没有交换机，还有就是说没有四层设备。从来不告诉我们什么时候能设备能上线交付给我们，不派专人催着这事，一点谱都没有。本来没有想好怎么用这些设备，先提前一个月申请上线，得我们想清楚了，他们却说又得换机房。网络怎么老是出问题，他们怎么规划的。开发的代码太不靠谱，一上线就引发用户投诉，只能回滚到老版本。开发人员的技术能力不行，写不出能用的版本。开发要求有一个跟生产环境一样的测试环境，这不可能有的。 而开发团队却说： 他们又不让我们碰线上的系统，生产环境是什么样，我们都不知道，没法开发代码。我们辛苦开发几个月，上线出问题又直接回滚了，心情很不好受。代码在测试环境或我的机器跑的好好的呀，怎么一上线就出问题呢。测试怎么测的，那么多问题发现不了。我们希望产品运维同事帮忙搭一个跟线上一模一样的测试环境。 另外，测试团队的人也许会说： 开发人员不写规定写单元测试代码。想着能用一个自动的集成测试环境，因为开发的原因，老是实现不了。测试环境跟生产环境不一样，好多问题才发现还有那么多的bug没有解决，产品就催着上线。 二、技术团队之间配合不好的影响上面看到的团队之间的冲突和抱怨问题虽然都不一样，产生的影响确是类似的：产品上线的进度延误，整个团队很难正常交付新版本。产品上线后问题很多，影响用户的访问。团队的士气很差。 最近又发生了运维团队与开发团队之间的配合不好的问题，影响及原因如下：新产品上线延误了两个星期，正常情况下一天就可以上线。原因是开发考虑不周，测试环境中没有发现，到上线前才发现部署到多台机器上后，按开发原先计划的方式多台机器无法协作完成任务。还有就是在设计阶段没有考虑生产环境的状况，在上线的过程中需要做出对应的代码调整。上线后质量不稳定，出现多次紧急修复。原因同上。 临时增加硬件投入。新产品中有个组件采用全新的技术方案，跟原来的LAMP体系不兼容，所以需要新增机器，单独部署。 除低了服务可用性标准，并产生了遗留问题。因为临时需要增加硬件，而恰好又只有一台，这样就形成了单点，如果该机器出现故障，服务将全部中断。另外，由于开发前设计上考虑不周，跟别的组件集成时产生别的单点。所以这些降低了服务的可用性，以后还得想办法解决。除此之外，组件采有新的软件，安装、服务起停以及软件配置的管理都是纯手工打造，以后还得找时间纳入到自动配置管理中。 影响了团队士气。在上线过程中开发、测试和运维都觉得不舒服，相互之间产生了抱怨。如果不处理好，会影响以后的配合。 虽然，有些问题确实需要靠某些团队提高自身的人员技能才能解决好，但这些团队能够形成一股合力的话，同样的人员组合肯定会产生更好的效果。 三、过去解决团队配合问题的方法第一次碰到团队之间的配合问题时，我们还没来得及解决的时候，公司战略调整，整个开发和系统运营团队转给了另一个大部门。但我们在别的地方重新梳理技术团队时，后来又没有出现这种问题，回想起来，我们的做法是： 部分开发人员有生产环境中服务器的帐号，可以观察代码的运转情况，少数核心开发人员还有sudo权限，当然他们也不会随便修改服务器的设置 开发时一开始就会跟系统运维团队沟通，在代码中增加数据收集的接口和监控接口，这样上线后，很容易收集产品的性能数据，并能方便地对运行状态进行监控与报警生产环境中也有沙箱与beta环境，这样大的版本从测试中过渡到生产环境前，先在沙箱环境中适应一段时间，这样能相对平稳过渡到生产环境 部分开发人员临时转到系统运维团队工作一到二个季度，跟系统运维同事一起上线产品，解决产品在运行中发生的问题，这样更好地了解代码如何在生产环境中运行，回去之后能更好地运维同事沟通，开发出来的代码更容易在生产环境中运行 这样，不同团队之间虽然有职责上的明确分工，但在中间的配合的部分做了不少柔性处理。另外，开发、运维与测试等团队中的核心人员之间本身就有认同感，大家一开始的目标就是奔着公司能成功来的，这是没有出配合问题的根本原因。这一点其实跟DevOps的核心点类似，既然如此，何不重新审视一下DevOps，并参考着解决团队之间的配合问题呢。 四、DevOpsDevOps是2010年从欧洲传过来的概念，最先是由一群有着跨学科技能的工程师提出来的，为了解决下面的问题： 推出新功能和解决老问题的周期过长 新产品或新版本上线充满风险，代码能否在生产环境中稳定运行，没有人有信心，只能艰难地推上去，再看是不是有问题 不同团队相互隔离，配合差。如开发人员收到问题后，第一反应是“在我的机器上工作得好好的呀” 我认为DevOps的核心是不管你是开发者、测试人员、管理者、DBA、网络工程师还是系统管理员，大家都是一起的，只有一起努力给客户提供稳定而高质量的软件服务，实现公司的商业利益才会有别的，包括自己的工作机会。 所以，DevOps实际是给各个团队之间搭桥，让他们不仅仅是依靠上线申请单这样的鸿雁传书工具进行沟通，而且经常离开自己的孤岛，走到别人的岛上去，了解别人，并提供自己的想法，帮助对方。 DevOps更象是一种运动，每家公司都需要根椐自身的特点进行借鉴，推动团队之间的协作与合作。需要在三个方面努力： 人员 一方面对现有人员进行培训，鼓励他们了解别的团队的工作、面临的挑战等，让他们用自己的特长去审视和帮助别的团队，另一方面也想办法招一些全面的技术人才，在不同团队之间搭出一些适用的桥来。 流程 在研发的前期，让系统运维同事参与起来，一起搭建测试环境，验证想法，或者也可以在一些项目团队中直接配有系统、开发和测试以及产品人员，一起为产品的上线努力。出现问题的时候，一起想方法找到问题的真正根源，避免相互推托，将解决方案落实在以后的研发过程中。从绩效考核流程上也需要考虑协作因素。 工具 说实在的，大家针对DevOps在工具方面其实讨论得更多，这里面跟敏捷有些类似之处。快速的系统部署和自动化产品代码发布方面的工具显得尤为重要了。 为了避免校弯过正，走向另一个极端，也需要避免下面的对DevOps的常见误解： DevOps意味着要给开发者root权限 可以给开发者加sudo权限，运行指定的命令，比如重启web服务。让开发者更多地了解生产环境和产品的运行状况，但并不意味着让开发者象管理员一样的去管理机器。所有系统管理员需要写代码，所有开发者需要上架机器在系统管理和开发者各个领域仍然需要各自的专家，如存储、网络、安装、javascript等专门的人才，DevOps并不意味着让大家不做自己专长的事情。 你一定要用某个工具，不然就不是DevOps一些技术和自动化的工具对推动各个团队之间协作很有帮助，但是还是需要聚焦于要解决的问题，根椐问题和组织的特点选择合适的工具。 我们需要招聘DevOpsDevOps不是一个新的岗位 五、结合DevOps，解决团队配合问题管理人员关注团队之间的沟通机制及氛围： 以新版能在生产环境中可靠稳定运行为目标，形成协作的氛围。在项目的早期，立项之间，运维、开发与测试就进行沟通，可能的话坐在一起，面对面沟通。 在项目上线前，除了测试功能，还要关注部署、备份、监控、安全以及配置管理，在早期发现的问题越多，越能尽少后期的问题并避免影响用户体验。建立各个团队的核心成员定期沟通机制。 团队之间的协作纳入绩效考核过程中去。让开发人员了解运维工作、关注点及挑战，并从开发视角帮助运维：开发人员参与运维团队的内部培训，了解线上的系统。 了解运维如何定位并解决故障、如何监控系统的运转情况等。 少数开发人员可以跟运维一样发版本到生产环境中，让开发人员关注并了解自己代码的运行情况。 从运维的视角修改代码，方便运维人员进行日常的变更与调整，监控与报警。帮助运维人员修改puppet配置模板。 帮助运维人员编写与修改产品的发布脚本，提高自动化水平。 让运维人员了解开发过程的关注点及挑战，并从运维角度改善开发过程： 运维为开发在公司搭建基于虚拟机的测试环境，虚拟机的安装、配置管理以及代码的发布采用跟生产环境一样的方式。 开发人员与测试人员象运维一样发布版本到测试环境中。鼓励开发与测试人员修改puppet配置与模板，管理自己的虚拟机。在生产环境中建立了beta环境，开发人员可以直接发版本上去，让代码在最终上线前多一层缓冲。 运维去了解代码的模块结构，从运维的角度修改代码，让产品上线后更方便运维与适应生产环境的特点。 运维参与到持续的集成测试中，用自己的自动化知识帮助实现自动的集成测试等。","categories":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/categories/运维/"}],"tags":[{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"},{"name":"DevOps","slug":"DevOps","permalink":"http://yoursite.com/tags/DevOps/"}]},{"title":"在Editplus中配置java的(带包)编译(javac)和运行(java)的方法","slug":"在Editplus中配置java的(带包)编译(javac)和运行(java)的方法","date":"2016-09-06T13:07:04.000Z","updated":"2018-01-23T02:59:53.532Z","comments":true,"path":"2016/09/06/在Editplus中配置java的(带包)编译(javac)和运行(java)的方法/","link":"","permalink":"http://yoursite.com/2016/09/06/在Editplus中配置java的(带包)编译(javac)和运行(java)的方法/","excerpt":"首先打开Editplus,打开工具-配置自定义工具（或者使用快捷键Alt+G）：","text":"首先打开Editplus,打开工具-配置自定义工具（或者使用快捷键Alt+G）： 然后点击“组名”，将Group 1改为“Java编译与运行”： 然后点击“添加工具”-“程序”： 1添加编译功能 “菜单文字”里的内容修改为“JAVAC”； “命令”选择安装JDK后的BIN目录中的编译程序JAVAC.EXE，如果JDK 安装路径为“c:/jdk”，那么此路径为“c:/jdk/bin/javac.exe” （如果系统参数path已经设置，此处可以直接填写javac); “参数”选择“文件名称”，即显示为“(FileName)”；“初始目录”选择“文件目录”，显示为“(FileName)”； “初始目录”选择“文件目录”，显示为“(FileDir)”； 选择“捕获输出”复选框。（如果不选“捕获输出”复选框的话那么编译或者运行的时候都会自动弹出一个命令提示符），然后设置成如下： 2添加执行功能 “菜单文字”里的内容修改为“JAVA”； “命令”选择安装JDK后的BIN目录中的编译程序JAVA.EXE，路径为 “c:/jdk/bin/java.exe”（path已经设置的情况下，可以直接填写为java）； “参数”选择“文件名（不含扩展名）”，即显示为 “(FileNameNoExt)”；“初始目录”选择“文件目录”，显示为“(FileNameNoExt)”； “初始目录”选择“文件目录”，显示为“(FileDir)”；选择“捕获输出”复选框。然后设置成如下： 这样就完成了基本的配置工作，下面您就可以试着编写一个JAVA程序来测试一下，编译的所有信息都会显示在输出窗口中，双击某一行错误信息，EditPlus会自动定位到出错行。 但是，完成了上面的设置之后，如果程序中包含package（包），则程序编译可以通过，但是运行时却出现错误，如果需要使用Editplus来编译执行包含package的程序，则还需要进行如下的设置：3添加编译带包Java程序功能“菜单文字”里的内容修改为“JAVAC package”； “命令”填写为：javac –d .； “参数”选择“文件名称”，即显示为“(FileName)”；“初始目录”选择“文件目录”，显示为“(FileName)”； “初始目录”选择“文件目录”，显示为“(FileDir)”； 选择“捕获输出”复选框。需要注意的是，在-d后面要空一格再添加.。然后设置成如下： 4 添加执行带包Java程序功能“菜单文字”里的内容修改为“JAVA”； “命令”填写为：java； “参数”选择“当前选中内容”，加一个.后再选择“主文件名（不含扩展名）”，即显示为“(CurSel).(CurSel).(FileNameNoExt)”； “初始目录”选择“文件目录”，显示为“$(FileDir)”； 选择“捕获输出”复选框。完成上面的设置，Editplus就可以编译执行带package的Java程序了，但是需要注意的一点是，在编译完程序后，如果程序是带包的，需要先将包名选中，然后在执行“java package”命令。然后设置成如下： 这个时候配置就全部完成了，打开工具可以看见有四个快捷方式已经出现在最下面了，并且快捷键依次为ctrl+1,ctrl+2,ctrl+3,ctrl+4: 下面测试一下，编写一个带包的java程序并且保存在任意一个位置，然后编译(这里两个编译不管java源文件有没有包名都可以用，但是注意编译分别有两个：ctrl+1和ctrl+3，ctrl+1编译之后就会在当前目录生成一个类文件，而ctrl+3编译之后会根据包名自动生成对应的文件夹，并在文件夹的最里层生成一个类文件)，可以看见在下面控制台中显示成功了：（注意如果不带包编译（ctrl+1）源文件和类文件就是在同一个目录下的，如果带包编译（ctrl+3）源文件和类文件就都是分开的） 然后运行（注意运行也有两个，ctrl+2只有在没有包名的情况下才可以使用，而ctrl+4只有在带包名的情况下才可以使用，并且注意使用之前必须先选中包名，不能选多了，也不能选少了），如图，运行成功： 面说说还有一种特殊情况，我们现在的配置的运行的动作是也就是说我们编译之后运行后的结果不会自动弹出命令提示符显示，而是在下面的控制台中显示，那么就会有一种特殊情况了，就是如果当java程序需要用户输入的时候我们该怎么输入，我们直接输入是不行的，方法就是在控制台上右击 然后点击键盘输入 当然如果觉得这样麻烦的话也可以不设置成而设置成无，那么运行的时候就会自动弹出我们熟悉的命令提示符了：","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"Editplus","slug":"Editplus","permalink":"http://yoursite.com/tags/Editplus/"}]},{"title":"在win7环境下oracle10g安装问题","slug":"在win7环境下oracle10g安装问题","date":"2015-05-21T13:07:04.000Z","updated":"2018-01-23T02:43:59.288Z","comments":true,"path":"2015/05/21/在win7环境下oracle10g安装问题/","link":"","permalink":"http://yoursite.com/2015/05/21/在win7环境下oracle10g安装问题/","excerpt":"虽然oracle10g这个版本已经比较老，但是他比较经典。并且许多高校都用这个版本。所以把安装过程中所有问题贴出来。 1. ORACLE 10g下载地址现在直接点击不能下载了要经过oracle许可才可以下载如果嫌麻烦可以用迅雷直接下载32位：(经检验64位电脑也可以用)","text":"虽然oracle10g这个版本已经比较老，但是他比较经典。并且许多高校都用这个版本。所以把安装过程中所有问题贴出来。 1. ORACLE 10g下载地址现在直接点击不能下载了要经过oracle许可才可以下载如果嫌麻烦可以用迅雷直接下载32位：(经检验64位电脑也可以用) Oracle Database 10g Release 2 (10.2.0.1.0) Enterprise/Standard Edition forMicrosoft Windows (32-bit) http://download.oracle.com/otn/nt/oracle10g/10201/10201_database_win32.zip 2、 然后解压3、 退出360等，最好关闭防火墙。4、 让陈旧的oracle10g支持高大上的win7，呵呵：更改解压好的文件夹里面：.. \\database\\stage\\prereq\\db下的refhost.xml文件，在 任意一个之后增加1234&lt;!--MicrosoftWindows 7--&gt; &lt;OPERATING_SYSTEM&gt; &lt;VERSION VALUE=&quot;6.1&quot;/&gt;&lt;/OPERATING_SYSTEM&gt; 5、 更改.. \\database\\install下的oraparam.ini文件，增加如下项：1234567Windows=5.0,5.1,5.2,6.0,6.1[Windows-6.1-required]#Minimum display colours for OUI to runMIN_DISPLAY_COLORS=256#Minimum CPU speed required for OUI#CPU=300[Windows-6.1-optional] 6、 右击“stuep.exe”文件–》选择“属性”–》兼容性–》选中兼容系统然后就可以开始安装了，（以管理员身份运行此程序）首先会弹出一个框说是找不到先决条件(这个很正常，因为上面被你更改了配置)，不要紧张，耐心等待一会就会开始安装了，千万不要关闭这个窗口。 7、 ERROR 2正在检查网络配置要求…检查完成。此次检查的总体结果为: 失败 &lt;&lt;&lt;&lt; 问题: 安装检测到系统的主 IP 地址是 DHCP 分配的地址。 建议案: Oracle 支持在具有 DHCP 分配的 IP 地址的系统上进行安装。但在安装之前, 必须将Microsoft LoopBack Adapter 配置为系统的主网络适配器。有关在配置有 DHCP 的系统上安装软件的详细信息, 请参阅 Installation Guide。 解决方案：1.单击开始图标，在智能搜索中输入“hdwwiz”，在搜索结果中鼠标右键单击该程序，使用“以管理员身份运行”方式来启动。 根据操作系统向导，选择“安装我手动从列表选择的硬件（高级）”。3.在硬件列表中，选择“网络适配器”。4.选择“Microsoft”厂商，并在右边网络适配器列表中选中“MicrosoftLoopback Adapter”，下一步按照向导完成安装。5 然后进入 控制面板\\网络和 Internet\\网络连接 把当前的本地连接禁止，然后给新增的Microsoft LoopBack Adapter本地连接指定个IP:192.168..0.1，然后启动。OK,然后点Oracle中的重试，this’s Problem Resolve！ 8、ERROR 2正在检查网络配置出现错误：”无法确定主机的IP地址时产生异常错误” 问题原因：找不到本机系统的IP地址，无法解析机器名。 解决办法：在hosts文件下手动修改。 （1）打开c:\\windows\\system32\\drivers\\etc\\hosts文件 手动加入：12127.0.0.1 localhost192.168.0.1 lenovothink 第二行，每台机器不一样！那么 怎么找到自己机器的IP地址和机器名？ （1） IP地址网络连接-&gt;本地连接（2） 本机的机器名：右键 我的电脑 即可看到。 情况3:如果企业管理控制器打不开怎么办呢？ 检查自己的IP地址与host文件中的是否一致。 如果不一致，更改host 如果一致重启电脑即可。 情况四：出现错误时登录企业管理器时出现的界面 出现这种错误一般是因为没有设置时区，一般默认的是agentTZRegion=GMT，也就是GMT。所以大家只要设置了这个东西，然后重新启动dbconsole就可以了。下面是设置以及重新启动dbconsole的全过程： 第一步，在Oracle安装目录中找打这个文件emd.properties（以往大家都是找不到这个文件在哪里），D:\\oracle\\product\\10.2.0\\db_1\\lenovothink_orcl\\sysman\\config，我的这个文件就是在这个路径下。估计大家都能找到这里D:\\oracle\\product\\10.2.0\\db_1，再往下就是lenovothinkorcl文件夹，这个是我的计算机名数据库全局变量，大家只要找到以自己计算机命名的这个文件即可，然后依次找到sysman\\config这个路劲下，然后就找到了emd.properties这个文件。然后用记事本打开这个文件，在此文件的最后一行你就可以看到agentTZRegion=GMT。 第二步，将agentTZRegion=GMT中的GMT改成Asia/Shanghai，也就是agentTZRegion=Asia/Shanghai，这里有个问题就是Asia一定首字母大写，Shanghai的首字母也要大些，你也可以用其他的地区，比如Asia/Beijing，不过我试过这个在我的机器上行不通，而改成Shanghai之后便可以正确显示，这个我也不清楚为什么，关于时区的列表参考：10.2.0\\db_1\\sysman\\admin\\supportedtzs.lst这个路径的文件去查找下中查找。改完后保存就行。 第三步，在cmd下输入输入此命令，&gt;setoracle_sid=orcl（orcl也就是数据库全局变量名，也就是数据库名），当然回车之后没任何反应。如下图： 第四步，继续输入命令&gt;emctlstop dbconsole（大家一定要注意emctl，最后一个字母是L，不是1，笔者因为把l弄成1，费了好大劲，希望大家不要犯我的错误）。这一步就是关闭dbconsole，回车之后如下图： 第五步，最后一步，启动原来关闭的dbconsole服务。键入命令&gt;emctl start dbconsole，回车之后如下图： 好了，经过这些操作之后大家重新启动浏览器，然后重新登录企业管理器就会发现java.lang.Exception:Exception in sending Request :: null这个错误没有了。我重新启动浏览器，重新登录后的界面如下图： Fujia附加的，卸载过程： 停止所有与ORACLE相关的服务。Ctrl+alt+delete….. 使用OUI（OracleUniversal Installer）卸载Oracle软件。 “开始”-&gt;“程序”-&gt;“Oracle-OraDb110g_home1/Oracle installation product/Universalinstaller.或者安装的那个程序：setup.exe也可以卸载。 3.删除注册表内容。 运行regedit命令，删除下面内容：HKEY_LOCAL_MACHINE/SOFTWARE/ORACLE注册表键，删除此键。 HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services，删除Services键下所有以oracle为首的键。 HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Services/Eventlog/Application， 删除此键下所有以oracle为首的键。 HKEY_CLASSES_ROOT，删除此键下所有以Ora，Oracle，Orcl，EnumOra 为前缀的键。 HKEY_CURRENT_USER/Software/Microsoft/Windows/CurrentVersion/Explorer/MenuOrder/StartMenu/Programs，删除此键下所有以oracle为首的键。 HKEY_LOCAL_MACHINE/SOFTWARE/ODBC/ODBCINST.INI注册表键，删除了MicrosoftODBC FOR ORACLE注册表键以外的所有有Oracle字样的键值。 4.最后在文件系统内删除ORACLE相关的文件及目录：如果无法删除，就用360粉碎删除。 5.重新启动。","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"win7","slug":"win7","permalink":"http://yoursite.com/tags/win7/"},{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"The Myeclipse executable launcher was unable to locate its companion shared library","slug":"The Myeclipse executable launcher was unable to locate its companion shared library","date":"2015-03-28T13:07:04.000Z","updated":"2018-01-23T02:35:22.516Z","comments":true,"path":"2015/03/28/The Myeclipse executable launcher was unable to locate its companion shared library/","link":"","permalink":"http://yoursite.com/2015/03/28/The Myeclipse executable launcher was unable to locate its companion shared library/","excerpt":"The Myeclipse executable launcher was unable to locate its companion shared library 打开myeclipse的时候弹出：The Myeclipse executable launcher was unable to locate its companion shared library 解决办法：","text":"The Myeclipse executable launcher was unable to locate its companion shared library 打开myeclipse的时候弹出：The Myeclipse executable launcher was unable to locate its companion shared library 解决办法： 在安装目录下打开 myeclipse.ini发现 /MyEclipse/Common/的路径找不到了，因为修改了文件夹的名字。 因为上次装MyEclipse装在E盘 这次装在D盘 所以会有两个地方。 所以：1.根据ini文件的路径找到MyEclipse/Common/2.或者更改ini文件到新的路径。 1234567891011121314151617#utf8 (do not remove) #utf8 (do not remove) -startup E:/本机常用软件/MyEclipse/Common/plugins/org.eclipse.equinox.launcher_1.2.0.v20110502.jar --launcher.library E:/本机常用软件/MyEclipse/Common/plugins/org.eclipse.equinox.launcher.i18n.win32.win32.x86_4.2.0.v201201111650 -install D:\\Program Files\\MyEclipse -vm E:\\本机常用软件\\MyEclipse\\Common\\binary\\com.sun.java.jdk.win32.x86_1.6.0.013\\jre\\bin\\javaw.exe -configuration D:\\Program Files\\MyEclipse\\configuration -vmargs -Xmx512m -XX:MaxPermSize=256m -XX:ReservedCodeCacheSize=64m -Dosgi.nls.warnings=ignore","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"报错","slug":"报错","permalink":"http://yoursite.com/tags/报错/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"},{"name":"myeclipse","slug":"myeclipse","permalink":"http://yoursite.com/tags/myeclipse/"}]},{"title":"破解myeclipse10时找不到myeclipse-Common-plusgin","slug":"破解myeclipse10时找不到myeclipse-Common-plusgin","date":"2015-03-27T13:07:04.000Z","updated":"2018-01-23T02:34:34.728Z","comments":true,"path":"2015/03/27/破解myeclipse10时找不到myeclipse-Common-plusgin/","link":"","permalink":"http://yoursite.com/2015/03/27/破解myeclipse10时找不到myeclipse-Common-plusgin/","excerpt":"破解myeclipse10时找不到myeclipse/Common/plusgin 说明你原来安装过myeclipse，这个文件夹有默认跑到原来的路径了。 解决方法，查看你最新安装的路径下的 .ini文件（myeclipse.ini）。 里面有myeclipse/Common/plusgin的路径","text":"破解myeclipse10时找不到myeclipse/Common/plusgin 说明你原来安装过myeclipse，这个文件夹有默认跑到原来的路径了。 解决方法，查看你最新安装的路径下的 .ini文件（myeclipse.ini）。 里面有myeclipse/Common/plusgin的路径","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"报错","slug":"报错","permalink":"http://yoursite.com/tags/报错/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"},{"name":"myeclipse","slug":"myeclipse","permalink":"http://yoursite.com/tags/myeclipse/"}]},{"title":"myeclipes配置tomecat时，一点击就报错89","slug":"myeclipes配置tomecat时，一点击就报错89","date":"2015-03-27T13:07:04.000Z","updated":"2018-01-23T02:34:14.488Z","comments":true,"path":"2015/03/27/myeclipes配置tomecat时，一点击就报错89/","link":"","permalink":"http://yoursite.com/2015/03/27/myeclipes配置tomecat时，一点击就报错89/","excerpt":"myeclipes配置tomecat时，一点击就报错89 因为你没有注册 myeclipes！ 真心的。","text":"myeclipes配置tomecat时，一点击就报错89 因为你没有注册 myeclipes！ 真心的。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"报错","slug":"报错","permalink":"http://yoursite.com/tags/报错/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"},{"name":"myeclipse","slug":"myeclipse","permalink":"http://yoursite.com/tags/myeclipse/"}]}]}